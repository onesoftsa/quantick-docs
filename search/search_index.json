{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Neutrino API O neutrino \u00e9 uma API em Python para implementar estrat\u00e9gias de algotrading no mercado brasileiro. Ela d\u00e1 acesso \u00e0 uma engine desenvolvida em C++ que cuida de todas as intera\u00e7\u00f5es com a B3 e est\u00e1 divida nos seguintes conjuntos: Estruturas de an\u00e1lise: book, trades (ticks), candles e indicadores Fun\u00e7\u00f5es de configura\u00e7\u00e3o Callbacks O acesso \u00e0 estes conjuntos \u00e9 feito pelos objetos market , utils , oms e position . A API tamb\u00e9m realiza alguns callbacks para seu c\u00f3digo em Python quando certos eventos ocorrem. Portanto, voc\u00ea pode implementar os m\u00e9todos abaixo: initialize (obrigat\u00f3rio) on_data (opcional) order_update (obrigat\u00f3rio se estrat\u00e9gia enviar ordens) order_filled (opcional) set_parameters (obrigat\u00f3rio se rodar pelo Quantick) get_parameters (obrigat\u00f3rio se rodar pelo Quantick) finalize (opcional) Preparando o ambiente local Para preparar seu ambiente para testar o neutrino localmente voc\u00ea precisa clonar este reposit\u00f3rio, instalar o Docker e o Make na sua m\u00e1quina (se estiver usando windows, pode querer fazer isso usando o chocolatery ). Depois, preencha o arquivo scripts/credentials.yml seguindo o arquivo exemplo dispon\u00edvel na mesma pasta. Finalmente, inicie o Docker e use os comandos abaixo. Isso iniciar\u00e1 uma estrat\u00e9gia demo para testar o ambiente. Pressione Ctrl+A D para terminar. $ make docker-build $ make example Para instalar diferetes m\u00f3dulos do Python para serem utilizadas dentro de suas estrat\u00e9gias, inicie a imagem base do docker e instale os pacotes desejados utilizando o pip . $ make base-env $ pip3.7 install [PACKAGE NAME] Antes de terminar o container atual, inicie outro terminal e siga estas instru\u00e7\u00f5es para comitar as mudan\u00e7as que voc\u00ea fez como uma nova imagem. Assim voc\u00ea pode voltar a utiliz\u00e1-la mais tarde, sem precisar reinstalar os m\u00f3dulos novamente. $ docker ps -a $ docker commit [CONTAINER_ID] neutrino-1 $ doker image Finalmente, termine o ambiente que utilizou para fazer as instala\u00e7\u00f5es utilizando Ctrl+A D e inicie um novo container para testar suas estrat\u00e9gias. $ make neutrino-env Arquivos de configura\u00e7\u00e3o Market Data O arquivo de configura\u00e7\u00e3o determina os par\u00e2metros para execu\u00e7\u00e3o do Neutrino. O formato do arquivo \u00e9 JSON, confira um exemplo: { \"Algorithm\" : \"python\", \"CPUMask\" : 15, \"ExecutionClient\" : \"XBMF.conf\", \"MDChannel\" : \"<IP>:<PORTA>\", \"PID\" : 0, \"Parent\" : 0, \"FrontendIdleTimeout\": 60, \"pos\": { \"DI1F21\": { \"net\": -5, \"net_price\": 0.025 } }, \"Symbols\" : [ \"DOLM18\" ], \"class\" : \"SimpleCorpOrder\", \"import\" : \"algo_modules\" } Onde os par\u00e2metros dispon\u00edveis s\u00e3o: Nome Descri\u00e7\u00e3o Valores Algorithm Tipo de algoritmo \"python\", \"corporate\" Symbol Lista dos nomes dos ativos array de strings StrictRisk Se e somente se o simbolo de uma ordem n\u00e3o tenha uma configura\u00e7\u00e3o de risco, esse par\u00e2metro configura se tal ordem ser\u00e1 bloqueada ou n\u00e3o. Se \"true\": bloqueia (strict). Se \"false\": aceita. bool pos A chave \u00e9 o nome do ativo e o valor \u00e9 um dict composto por net e net_price , onde o primeiro termo se refere \u00e0 posi\u00e7\u00e3o atual no instrumento e net_price o seu pre\u00e7o m\u00e9dio. dict CPUMask M\u00e1scara usada pelo taskset para determinar aloca\u00e7\u00e3o de CPU pelo sistema operacional int PID Process ID atribuido pelo sistema operacional e preenchido pelo AlgoMan int FrontendIdleTimeout imeout para intera\u00e7\u00e3o com o frontend. Sem comunica\u00e7\u00e3o com o frontend al\u00e9m do timeout a estrategia \u00e9 encerrada. Se o valor igual a zero, esta valida\u00e7\u00e3o n\u00e3o \u00e9 feita int ExecutionClient Caminho para o arquivo com a configura\u00e7\u00e3o do cliente de ordens string class Nome do classe do algoritmo string import Pasta com os algoritmos string MDChannel IP e porta do Relay string, no formato <IP>:<porta> Para que este arquivo seja gerado corretamente, a estrat\u00e9gia deve ser cadastrada atrav\u00e9s do Admin com o atributo Classe no formato python: <import>:<class> e o atributo name como <class> . Order Routing O arquivo de configura\u00e7\u00e3o determina os par\u00e2metros para execu\u00e7\u00e3o do Neutrino relacionados ao envio de ordens. Segue o exemplo: port = 14006 user = neutrino password = neutrino account = DEMO exchange = XBMF prefix = XBMF. report-delay = 500 Onde os par\u00e2metros dispon\u00edveis s\u00e3o: Nome Descri\u00e7\u00e3o Valores port porta DTC do OMS int user nome de usu\u00e1rio para conex\u00e3o com o OMS string password senha do usu\u00e1rio para conex\u00e3o com o OMS string account conta para envio de ordens string exchange string prefix prefixo utilizado no client order id das ordens enviadas string report-delay Indica qual deve ser o tempo de delay da simula\u00e7\u00e3o. Caso seja colocado um valor negativo o c\u00f3digo interpreta como valor de delay 0. int Rodando estrat\u00e9gias no Docker No reposit\u00f3rio neutrino-devel , inclua a pasta com os arquivos relacionados \u00e0 estrat\u00e9gia que quiser testar na pasta strats/ e preencha o arquivo scripts/confs/strastlist.yml com um alias para sua estrat\u00e9gia (que utilizar\u00e1 com outro script), o nome da pasta onde os arquivos est\u00e3o e o nome da classe que ser\u00e1 importada pelo neutrino, conforme modelo na pasta scripts/confs/ . Depois disso, navegue para a pasta raiz do reposit\u00f3rio (onde fica o README) e rode: $ python scripts/create_algo.py -a <ALIAS> -id <ID para usar na pasta> -i <INSTRUMENTO PARA TESTAR> $ make neutrino-env J\u00e1 dentro do docker, rode: $ cd ~/onesoft/algos/algo<ID> $ neutrinov4 -c <ARQUIVO DA PASTA>.conf Isso iniciar\u00e1 o neutrino em modo de simula\u00e7\u00e3o, utilizando dados em tempo real, e chamar\u00e1 os callbacks para sua estrat\u00e9gia todo evento de book ou neg\u00f3cio. Para testar os comandos que implementar, digite em um novo console: $ cd ~/onesoft/algos/algo<ID> $ controller <ID> $ set <NOME ESTRAT\u00c9GIA> comandos-em-formato-json-aqui","title":"Primeiros passos"},{"location":"#neutrino-api","text":"O neutrino \u00e9 uma API em Python para implementar estrat\u00e9gias de algotrading no mercado brasileiro. Ela d\u00e1 acesso \u00e0 uma engine desenvolvida em C++ que cuida de todas as intera\u00e7\u00f5es com a B3 e est\u00e1 divida nos seguintes conjuntos: Estruturas de an\u00e1lise: book, trades (ticks), candles e indicadores Fun\u00e7\u00f5es de configura\u00e7\u00e3o Callbacks O acesso \u00e0 estes conjuntos \u00e9 feito pelos objetos market , utils , oms e position . A API tamb\u00e9m realiza alguns callbacks para seu c\u00f3digo em Python quando certos eventos ocorrem. Portanto, voc\u00ea pode implementar os m\u00e9todos abaixo: initialize (obrigat\u00f3rio) on_data (opcional) order_update (obrigat\u00f3rio se estrat\u00e9gia enviar ordens) order_filled (opcional) set_parameters (obrigat\u00f3rio se rodar pelo Quantick) get_parameters (obrigat\u00f3rio se rodar pelo Quantick) finalize (opcional)","title":"Neutrino API"},{"location":"#preparando-o-ambiente-local","text":"Para preparar seu ambiente para testar o neutrino localmente voc\u00ea precisa clonar este reposit\u00f3rio, instalar o Docker e o Make na sua m\u00e1quina (se estiver usando windows, pode querer fazer isso usando o chocolatery ). Depois, preencha o arquivo scripts/credentials.yml seguindo o arquivo exemplo dispon\u00edvel na mesma pasta. Finalmente, inicie o Docker e use os comandos abaixo. Isso iniciar\u00e1 uma estrat\u00e9gia demo para testar o ambiente. Pressione Ctrl+A D para terminar. $ make docker-build $ make example Para instalar diferetes m\u00f3dulos do Python para serem utilizadas dentro de suas estrat\u00e9gias, inicie a imagem base do docker e instale os pacotes desejados utilizando o pip . $ make base-env $ pip3.7 install [PACKAGE NAME] Antes de terminar o container atual, inicie outro terminal e siga estas instru\u00e7\u00f5es para comitar as mudan\u00e7as que voc\u00ea fez como uma nova imagem. Assim voc\u00ea pode voltar a utiliz\u00e1-la mais tarde, sem precisar reinstalar os m\u00f3dulos novamente. $ docker ps -a $ docker commit [CONTAINER_ID] neutrino-1 $ doker image Finalmente, termine o ambiente que utilizou para fazer as instala\u00e7\u00f5es utilizando Ctrl+A D e inicie um novo container para testar suas estrat\u00e9gias. $ make neutrino-env","title":"Preparando o ambiente local"},{"location":"#arquivos-de-configuracao","text":"","title":"Arquivos de configura\u00e7\u00e3o"},{"location":"#market-data","text":"O arquivo de configura\u00e7\u00e3o determina os par\u00e2metros para execu\u00e7\u00e3o do Neutrino. O formato do arquivo \u00e9 JSON, confira um exemplo: { \"Algorithm\" : \"python\", \"CPUMask\" : 15, \"ExecutionClient\" : \"XBMF.conf\", \"MDChannel\" : \"<IP>:<PORTA>\", \"PID\" : 0, \"Parent\" : 0, \"FrontendIdleTimeout\": 60, \"pos\": { \"DI1F21\": { \"net\": -5, \"net_price\": 0.025 } }, \"Symbols\" : [ \"DOLM18\" ], \"class\" : \"SimpleCorpOrder\", \"import\" : \"algo_modules\" } Onde os par\u00e2metros dispon\u00edveis s\u00e3o: Nome Descri\u00e7\u00e3o Valores Algorithm Tipo de algoritmo \"python\", \"corporate\" Symbol Lista dos nomes dos ativos array de strings StrictRisk Se e somente se o simbolo de uma ordem n\u00e3o tenha uma configura\u00e7\u00e3o de risco, esse par\u00e2metro configura se tal ordem ser\u00e1 bloqueada ou n\u00e3o. Se \"true\": bloqueia (strict). Se \"false\": aceita. bool pos A chave \u00e9 o nome do ativo e o valor \u00e9 um dict composto por net e net_price , onde o primeiro termo se refere \u00e0 posi\u00e7\u00e3o atual no instrumento e net_price o seu pre\u00e7o m\u00e9dio. dict CPUMask M\u00e1scara usada pelo taskset para determinar aloca\u00e7\u00e3o de CPU pelo sistema operacional int PID Process ID atribuido pelo sistema operacional e preenchido pelo AlgoMan int FrontendIdleTimeout imeout para intera\u00e7\u00e3o com o frontend. Sem comunica\u00e7\u00e3o com o frontend al\u00e9m do timeout a estrategia \u00e9 encerrada. Se o valor igual a zero, esta valida\u00e7\u00e3o n\u00e3o \u00e9 feita int ExecutionClient Caminho para o arquivo com a configura\u00e7\u00e3o do cliente de ordens string class Nome do classe do algoritmo string import Pasta com os algoritmos string MDChannel IP e porta do Relay string, no formato <IP>:<porta> Para que este arquivo seja gerado corretamente, a estrat\u00e9gia deve ser cadastrada atrav\u00e9s do Admin com o atributo Classe no formato python: <import>:<class> e o atributo name como <class> .","title":"Market Data"},{"location":"#order-routing","text":"O arquivo de configura\u00e7\u00e3o determina os par\u00e2metros para execu\u00e7\u00e3o do Neutrino relacionados ao envio de ordens. Segue o exemplo: port = 14006 user = neutrino password = neutrino account = DEMO exchange = XBMF prefix = XBMF. report-delay = 500 Onde os par\u00e2metros dispon\u00edveis s\u00e3o: Nome Descri\u00e7\u00e3o Valores port porta DTC do OMS int user nome de usu\u00e1rio para conex\u00e3o com o OMS string password senha do usu\u00e1rio para conex\u00e3o com o OMS string account conta para envio de ordens string exchange string prefix prefixo utilizado no client order id das ordens enviadas string report-delay Indica qual deve ser o tempo de delay da simula\u00e7\u00e3o. Caso seja colocado um valor negativo o c\u00f3digo interpreta como valor de delay 0. int","title":"Order Routing"},{"location":"#rodando-estrategias-no-docker","text":"No reposit\u00f3rio neutrino-devel , inclua a pasta com os arquivos relacionados \u00e0 estrat\u00e9gia que quiser testar na pasta strats/ e preencha o arquivo scripts/confs/strastlist.yml com um alias para sua estrat\u00e9gia (que utilizar\u00e1 com outro script), o nome da pasta onde os arquivos est\u00e3o e o nome da classe que ser\u00e1 importada pelo neutrino, conforme modelo na pasta scripts/confs/ . Depois disso, navegue para a pasta raiz do reposit\u00f3rio (onde fica o README) e rode: $ python scripts/create_algo.py -a <ALIAS> -id <ID para usar na pasta> -i <INSTRUMENTO PARA TESTAR> $ make neutrino-env J\u00e1 dentro do docker, rode: $ cd ~/onesoft/algos/algo<ID> $ neutrinov4 -c <ARQUIVO DA PASTA>.conf Isso iniciar\u00e1 o neutrino em modo de simula\u00e7\u00e3o, utilizando dados em tempo real, e chamar\u00e1 os callbacks para sua estrat\u00e9gia todo evento de book ou neg\u00f3cio. Para testar os comandos que implementar, digite em um novo console: $ cd ~/onesoft/algos/algo<ID> $ controller <ID> $ set <NOME ESTRAT\u00c9GIA> comandos-em-formato-json-aqui","title":"Rodando estrat\u00e9gias no Docker"},{"location":"mktdata/","text":"Market Data API Instrumento O InstrumentRegister representa o objeto pelo qual s\u00e3o disponibilizados o book e o buffer trades. Assinatura Para assinar um instrumento use a fun\u00e7\u00e3o add especifique o nome do ativo, o tamanho do buffer de trades e as callbacks de mercado: Fun\u00e7\u00e3o Descri\u00e7\u00e3o add(<symbol>, book_callback=on_data, trade_callback=on_data, trade_buffer_size=64) Adiciona um instrumento, usando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' book_callback: callback a ser disparada na notifica\u00e7\u00e3o de mudan\u00e7a de book trade_callback: callback a ser disparada na notifica\u00e7\u00e3o de trade trade_buffer_size: quantidade m\u00e1xima de trades contidos no buffer a cada notifica\u00e7\u00e3o Um objeto do tipo InstrumentRegister \u00e9 devolvido no caso de sucesso. Caso o s\u00edmbolo n\u00e3o seja v\u00e1lido ou o tamanho do buffer ultrapasse 64 elementos, None \u00e9 devolvido. Por exemplo: from neutrino import market # Uso de duas callbacks customizadas self.win = market.add( 'WINQ19', book_callback=on_book, trade_callback=on_trade, trade_buffer_size=10) # Cancelada callback de book e uso de callback default on_data para trades self.wdo = market.add('WDOQ19', book_callback=None, trade_buffer_size=50) A callback default \u00e9 chamada on_data e precisa ser implementada pelo usu\u00e1rio para ser notificado sobre as mudan\u00e7as de book e trades. As assinaturas est\u00e3o baseadas em ativos podendo ser feitas em qualquer momento da opera\u00e7\u00e3o da estrat\u00e9gia. A assinatura de um ativo gera automaticamente estruturas de dados preenchidas com informa\u00e7\u00f5es do book e os trades que acontecem nesse momento. Vale lembrar que os trades do come\u00e7o do dia n\u00e3o est\u00e3o nesta lista. Acesso Caso o instrumento n\u00e3o tenha sido salvo no momento da assinatura, \u00e9 poss\u00edvel utilizar a fun\u00e7\u00e3o get para recuper\u00e1-lo: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Devolve um instrumento j\u00e1 cadastrado usando como argumento a string com o nome do s\u00edmbolo. Caso o nome seja inv\u00e1lido None \u00e9 devolvido. Por exemplo: self.instrument = market.get('WINQ19') Desassinatura Para remover um instrumento utilize o objeto obtido pela cria\u00e7\u00e3o do mesmo: self.instrument = neutrino.market.get('WINDOM19') if neutrino.market.remove(self.instrument): print('success') A fun\u00e7\u00e3o remove \u00e9 parte do m\u00f3dulo market: Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove(<instrument>) Remove um instrumento. O instrument deve ser um objeto v\u00e1lido devolvido pela assinatura ou obtido pelo m\u00e9todo get. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto instrument passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. Na remo\u00e7\u00e3o de um instrumento os candles relacionado a ele n\u00e3o s\u00e3o removidos de maneira autom\u00e1tica, eles continuam sendo atualizados. Callbacks Ao assinar determinada estrutura de an\u00e1lise \u00e9 poss\u00edvel configurar as futuras callbacks, podendo mudar a callback default on_data para outra fun\u00e7\u00e3o, por exemplo: def initialize(self, symbols): market.add('WINQ19', book_callback=on_win_callback, trade_callback=None) market.add('WDOM19', book_callback=None, trade_callback=on_wdo_callback) def on_win_callback(self, update): print('WINQ19 bar received') def on_wdo_callback(self, update): print('WDOQ19 bar received') Inclusive \u00e9 possivel cancelar a callback para determinada assinatura. No exemplo a seguir, o usu\u00e1rio cancela a callback do book, por\u00e9m mantem as notifica\u00e7\u00f5es dos trades por meio da callback default on_data: def initialize(self, symbols): market.add('WINQ19', book_callback=None) def on_data(self, update): print('WINQ19 trade') Atributos e m\u00e9todos Os atributos a seguir est\u00e3o dispon\u00edvel para uma instancia do InstrumentRegister : name: nome do s\u00edmbolo book: book de ofertas trades: buffer circular de trades min_order_qty: lote m\u00ednimo price_increment: tick m\u00ednimo ready(): testa se o estado \u00e9 diferente de OFFLINE Book bid: conjunto de ordens do lado da compra ask: conjunto de ordens do lado da venda state: enumerado com o estado do book, segundo a p\u00e1gina 64 desta documenta\u00e7\u00e3o. sequence: sequencial do book. Id \u00fanico da atualiza\u00e7\u00e3o mais recente do book de ofertas name: nome do s\u00edmbolo Cada item do bid e ask tem os seguintes atributos: price: pre\u00e7o da ordem quantity: quantidade da ordem detail: corretora order_id: SecondaryOrderID, definido pela Bolsa virtual_md_id: ID atribu\u00eddo \u00e0 ordem pelo neutrino Para imprimir o topo do book \u00e9 poss\u00edvel: print(instrument.bid[0].price) print(instrument.ask[0].price) Trades O acesso \u00e9 feito por meio de indices. O valor m\u00e1ximo \u00e9 determinado pelo par\u00e2metro trade_buffer_size. Os atributos de cada item s\u00e3o: trade_id: Id do trade na B3 datetime: hor\u00e1rio local quando o neg\u00f3cio foi executado price: pre\u00e7o do neg\u00f3cio quantity: quantidade do neg\u00f3cio buyer: contraparte compradora seller: contraparte vendedora status: \u00e9 o agressor indicator enviado pela bolsa. Pode ser R(trade de RLP), X(direto), -(trade iniciado pelo vendedor) e +(iniciado pelo comprador) Candles O CandleRegister representa a estrutura que contem os candles para determinado ativo e as propriedades para sua constru\u00e7\u00e3o como intervalo, tick, quantidade inicial de barras, entre outros. Est\u00e3o dispon\u00edveis os candles do tipo stick e renko. A sua assinatura pode ser feita da maneira a seguir: Assinatura A assinatura de um ativo pode ser feita por meio da fun\u00e7ao add_bar: Fun\u00e7\u00e3o Descri\u00e7\u00e3o add_bar(<symbol>,bar_count=100, interval=1) Adiciona um novo candle do tipo stick, utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' bar_count: n\u00famero de candles, default \u00e9 100. interval: intervalo para gera\u00e7\u00e3o dos candles, default \u00e9 1 minuto. Devolve um objeto do tipo CandleRegister. add_interday_bar(<symbol>,bar_count=100, interval='D') Adiciona um novo candle do tipo interday , utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' bar_count: n\u00famero de candles, default \u00e9 100 interval: intervalos poss\u00edveis s\u00e3o dia 'D' (default), semana 'W' e m\u00eas 'M' Devolve um objeto do tipo CandleRegister. add_renko(<symbol>,tick_count=2) Adiciona um novo candle do tipo renko, utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' tick_count: n\u00edveis de pre\u00e7o para cada tijolo, default \u00e9 2 A quantidade de dias considerados para o hist\u00f3rico \u00e9 15. Devolve um objeto do tipo CandleRegister. Por exemplo: from neutrino import market bar = market.add_bar(symbol, bar_count=100, interval=1) interday_bar = market.add_interday_bar(symbol, bar_count=10, interval='M') renko = market.add_bar(symbol, tick_count=5) A assinatura de um instrumento e de barras s\u00e3o independentes , sendo que o usu\u00e1rio pode solicitar os candles de um determinado ativo usando a fun\u00e7\u00e3o add_bar , add_interday_bar ou add_renko sem ter adicionado o instrumento por meio do add . As atualiza\u00e7\u00f5es de candle chegar\u00e3o atrav\u00e9s da callback especificada para o trade_callback daquele instrumento ou no on_data , se nenhuma callback tiver sido especificado. Acesso O armazenamento do candle \u00e9 responsabilidade do usu\u00e1rio, por\u00e9m caso o objeto n\u00e3o tenha sido salvo, \u00e9 poss\u00edvel recuper\u00e1-lo, utilizando a fun\u00e7\u00e3o get_bar , get_interday_bar ou get_renko : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_bar(<symbol>,bar_count=100, interval=1) get_interday_bar(<symbol>,bar_count=100, interval='D') get_renko(<symbol>,bar_count=2) Recupera um candle previamente cadastrado usando como argumentos: symbol: string com o nome do ativo a ser assinado. bar_count: n\u00famero de candles, default \u00e9 100. tick_count: n\u00edveis de pre\u00e7o para cada tijolo, default \u00e9 2. interval: intervalo para gera\u00e7\u00e3o dos candles, default \u00e9 1 minuto ou 'D'. Caso n\u00e3o exista um candle usando a combina\u00e7\u00e3o dos argumentos anteriores None \u00e9 devolvido , caso contr\u00e1rio o objeto do tipo CandleRegister Por exemplo: self.bar_win = market.get_bar('WINQ19') self.bar_win_count_1000 = market.get_bar('WINQ19', bar_count=1000) self.bar_win_interval_5 = market.get_bar('WINQ19', interval=5) self.bar_win_interval_day = market.get_interday_bar('WINQ19', interval='D') self.renko_win_10 = market.get_renko('WINQ19', tick_count=10) Atributos e m\u00e9todos open high low close timestamps quantity quantity_buy quantity_sell volume quantity_accumulated quantity_buy_accumulated quantity_sell_accumulated num_trades last_id ready() properties: objeto do tipo CandleProperties, que por sua vez possui: tick_count: n\u00edveis de pre\u00e7o para cada tijolo bar_count: n\u00famero de barras solicitadas interval: periodo do candle em minutos ou especifica\u00e7\u00e3o 'D', 'W', 'M' para interday symbol: nome do ativo Desassinatura Para remover um candle utilize o objeto CandleRegister devolvido na cria\u00e7\u00e3o do mesmo usando a fun\u00e7\u00e3o remove_bar , remove_interday_bar ou remove_renko : Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_bar(<bar>) remove_interday_bar(<bar>) remove_renko(<bar>) Remove um candle. O bar deve ser um objeto v\u00e1lido devolvido pela assinatura de um candle ou obtido pelo m\u00e9todo get_bar. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto bar passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. Por exemplo: from utils import market bar = market.add_bar('PETR4') if market.remove_bar(bar): print('success') Ao remover a assinatura de um candle todos os indicadores atrelados a ele tamb\u00e9m s\u00e3o removidos. Indicadores Os indicadores est\u00e3o naturalmente vinculados a um candle. Sendo que, a sua assinatura deve usar um objeto candle: self.bar_winq19 = neutrino.market.add_bar(\"WINQ19\") if self.bar_winq19.ready(): self.sma_winq19 = self.bar_winq19.add_sma(bar_count=10, source=neutrino.IndicatorSource.OPEN) print(self.bar_winq19.ready(), self.sma_winq19.ready()) # >> True, True Caso usu\u00e1rio n\u00e3o reserve uma vari\u00e1vel para salvar o indicador constru\u00eddo \u00e9 fornecido o seguinte mecanismo de acesso: for indicator in self.bar_winq19.get_indicators(): # retorna iterador print(\"Indicator \" + indicator.name + \" value: \" + str(indicator.values[-1])) Indicadores dispon\u00edveis O framework fornece os indicadores a seguir: Nome Assinatura Par\u00e2metros SMA add_sma(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada (conferir se\u00e7ao Source) EMA add_ema(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada MOM add_mom(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada SAMOM add_samom(bar_count=.., source=..., sa_bar_count=...) bar_count: quantidade de barras source: tipo de entrada sa_bar_count: quantidade de barras utilizadas na m\u00e9dia TRANGE* add_trange() SATR* add_satr(sa_bar_count=...) sa_bar_count: quantidade de barras utilizadas na m\u00e9dia ATR* add_atr(bar_count=...) bar_count: quantidade de barras ADX* add_atr(bar_count=...) bar_count: quantidade de barras SAADX* add_atr(bar_count=..., sa_bar_count=...) bar_count: quantidade de barras sa_bar_count: quantidade de barras utilizadas na m\u00e9dia PLUS_DI* add_plus_di(bar_count=...) bar_count: quantidade de barras MINUS_DI* add_minus_di(bar_count=...) bar_count: quantidade de barras BBANDS** add_bbands(bar_count=..., deviation_up=..., deviation_down=..., average=...) bar_count: quantidade de barras deviation_up: deviation_down: average: tipo de m\u00e9dia utiliza (conferir se\u00e7\u00e3o Average) SABBANDS** add_sabbands(bar_count=..., deviation_up=..., deviation_down=..., average=..., sa_bar_count=...) bar_count: quantidade de barras deviation_up: deviation_down: average: tipo de m\u00e9dia utiliza (conferir se\u00e7\u00e3o Average) sa_bar_count: quantidade de barras utilizadas na m\u00e9dia STDDEV add_stddev(bar_count=.., source=..., deviation_count=...) bar_count: quantidade de barras source: tipo de entrada deviation_count: * source utilizado: high, low, close ** source utilizado: close Acceso aos valores Os valores dos indicadores pode ser recuperado acessando o vetor de valores values: # Acessando o valor do indicador mais recente self.sma = candle.add_sma(10) print(self.sma.values[-1]) No caso do BBANDS e SABBANDS os valores devem ser acessados pelo vetor bands : # Acessando o valor do indicador mais recente self.sabbands = candle.add_bbands(bar_count=10, deviation_up=5, deviation_down=5, average=IndicatorAverage.SMA, sa_bar_count=5) print(self.sabbands.bands[0][-1]) print(self.sabbands.bands[1][-1] print(self.sabbands.bands[2][-1] Atributos Um indicador ao ser assinado ou ser recuperado usando a fun\u00e7\u00e3o get_indicators, possui a seguinte lista de atributos: values: lista com os valores do indicador bands: lista de 3 vetores com os valores para o BBANDS e SABBANDS last_id: id do valor de indicador atualizado mais recentemente name: nome do indicador (confira a coluna Nome na lista de Indicadores dispon\u00edveis) properties: itens da coluna Par\u00e2metros na lista de Indicadores dispon\u00edveis source bar_count sa_bar_count deviation_count deviation_up deviation_down average Todos os indicadores tem a lista anterior de atributos dispon\u00edveis independente do tipo de indicador. Source O argumento source para os indicadores \u00e9 determinado pelo enumerado neutrino.IndicatorSource, podendo ter os valores: NONE OPEN HIGH LOW CLOSE QUANTITY QUANTITY_SELL QUANTITY_BUY VOLUME QUANTITY_ACCUMULATED QUANTITY_SELL_ACCUMULATED QUANTITY_BUY_ACCUMULATED Average O argumento average para os indicadores BBANDS e SABBANDS \u00e9 determinado pelo enumador neutrino.IndicatorAverage, podendo ter os valores: SMA EMA WMA Desassinatura Para remover um indicador previamente criado \u00e9 necess\u00e1rio ter acesso ao objeto a ser removido. Use a fun\u00e7\u00e3o remove_indicator que \u00e9 um m\u00e9todo do CandleRegister. Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_indicator(<indicator>) Remove um indicador contido num candle. O indicator deve ser um objeto v\u00e1lido devolvido pela assinatura de um indicador ou obtido pelo m\u00e9todo get_indicators. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto indicator passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. No exemplo a seguir o objeto do indicador SMA \u00e9 salvo e utilizado para sua remo\u00e7\u00e3o: from utils import market bar = market.add_bar('PETR4') sma = bar.add_sma(10) if bar.remove_indicator(sma): print('success') Callbacks Callbacks inicio e fim A primeira callback da estrategia \u00e9 initialize. Esta fun\u00e7\u00e3o \u00e9 chamada pelo neutrino ap\u00f3s contrastar os ativos listados no arquivo de configura\u00e7\u00e3o da estrategia com o security list recebido pelo marketdata. De modo que, toda estrategia deve iniciar o seu processamento com instru\u00e7\u00f5es dentro da callback initialize. O par\u00e2metro symbols indica a lista de ativos dispn\u00edveis para uso. Este ativos correspondem ao mesmos especificados no arquivo de configura\u00e7\u00e3o da estrategia: # quantick.conf: \"Symbols\" : [ \"DI1F21\" , \"DI1F19\" , \"DI1F23\"], ... Considerando o arquivo anterior: def initialize(self, symbols) print([s for s in symbols]) # >> ['DI1F21', 'DI1F19', 'DI1F23'] A API tamb\u00e9m permite implementar a callback finalize (n\u00e3o obrigat\u00f3ria) que \u00e9 chamada quando a estrat\u00e9gia \u00e9 terminada por qualquer motivo: def initialize(self, symbols): neutrino.utils.quit() def finalize(self, reason): print(\"finalize:\" + str(reason)) QuitReason O neutrino sinaliza que a estrategia vai encerrar chamando a callback finalize. O par\u00e2metro reason indica o motivo do encerramento. Os valores para o QuitReason s\u00e3o: USER_QUIT: o usu\u00e1rio usou a chamada neutrino.utils.quit() ou usando CTRL+C ALGOMAN_QUIT: o Algoman enviou o comando Abort NO_MD_CONNECTION: perda de conex\u00e3o com a fonte de dados de mercado (Relay) NO_FRONTEND_CONNECTION: perda de conex\u00e3o com o frontend BAD_FD: falha na comunica\u00e7\u00e3o do neutrino com OMS ou Algoman ou Relay INVALID_PROTOCOL: pacote de dados recebido \u00e9 inv\u00e1lido OUT_OF_SYNC: a estrategia n\u00e3o consegue sincronizar ap\u00f3s 10 tentativas NO_OMS_CONNECTION: sem conex\u00e3o com o OMS Callback default, book, trade e candles O controle do volume de notifica\u00e7\u00f5es recebidas \u00e9 feito em parte pelo pr\u00f3prio usu\u00e1rio. Basicamente a fun\u00e7\u00e3o on_data ser\u00e1 disparada pelo Neutrino pela mudanca de book ou trades: No caso do book duas op\u00e7\u00f5es de atualiza\u00e7\u00e3o podem ser notificadas: bid e ask. No caso de trades, entende-se que os candles e indicadores tamb\u00e9m tem sido atualizados Quando acontecer a virada do periodo sem ter acontecido algum negocio o Neutrino notifica atualiza\u00e7\u00e3o dos candles/indicadores A callback default on_data tem como par\u00e2metro a estrutura update, tendo como membros os campos a seguir: symbol: nome do ativo atualizado e motivo da chamada da callback reason: vetor com a lista de acontecimentos motivo da chamada da callback bid_count: n\u00famero de atualiza\u00e7\u00f5es por parte do bid ask_count: n\u00famero de atualiza\u00e7\u00f5es por parte do ask trade_count: n\u00famero de trades status_changed: O campo reason \u00e9 um vetor ordenado levando em considera\u00e7\u00e3o como maior prioridade o acontecimento de um trade e a seguir o lado do book com maior quantidade de atualiza\u00e7\u00f5es. Por exemplo se existiram negocios e al\u00e9m disso bid_count > ask_count, ent\u00e3o: def on_data(self, update) print(update.symbol + ' - ' + ','.join(str(r) for r in update.reason)) # >> WINQ19 - TRADES, BID_SIDE, ASK_SIDE No exemplo a seguir o usu\u00e1rio assina book, trades, candle e indicadores para dois ativos diferentes. As mudan\u00e7as s\u00e3o recebidas pelo on_data e o pr\u00f3prio usu\u00e1rio \u00e9 respons\u00e1vel por determinar o tratamento de cada uma das op\u00e7\u00f5es poss\u00edveis: from neutrino import * def initalize(self) market.add_book(\"WINQ19\") market.add_book(\"PETR4\") self.winq_book = market.get_book(\"WINQ19\") self.petr_book = market.get_book(\"PETR4\") self.winq_candle = market.add_bar(\"WINQ19\", interval=1) self.petr_candle = market.add_bar(\"PETR4\", interval=5) self.winq_candle.add_sma(bar_count=5) self.petr_candle.add_sma(bar_count=10) self.petr_candle.add_adx() def on_data(self, update): if \"PETR4\" in update.symbol: self.on_petr_data(update) if \"WINQ19\" in update.symbol: self.on_winq_data(update) def on_petr_data(self, update): if UpdateReason.BID_SIDE in update.reason: self.on_petr_bid(update) if UpdateReason.ASK_SIDE in update.reason: self.on_petr_ask(update) if UpdateReason.TRADE in update.reason or \\ UpdateReason.NEW_BAR in update.reason: self.on_petr_candle(update) def on_winq_data(self, update): if UpdateReason.BID_SIDE in update.reason: self.on_winq_bid() if UpdateReason.ASK_SIDE in update.reason: self.on_winq_ask() if UpdateReason.TRADES in update.reason or \\ UpdateReason.NEW_BAR in update.reason: self.on_winq_candle() O framework permite tamb\u00e9m excluir a callback default de modo que as estruturas assinadas s\u00e3o atualizadas, por\u00e9m n\u00e3o existe notifica\u00e7\u00e3o deste acontecimento. Por exemplo, podem ser assinados book e trades por\u00e9m o book ser\u00e1 s\u00f3 consultado quando um trade acontecer. Para ter este efeito \u00e9 poss\u00edvel anular a callback do book: def initalize(self) market.add(\"PETR4\", book_callback=None) self.petr_book = market.get(\"PETR4\").book self.petr_trades = market.get(\"PETR4\").trades def on_data(self, update): # Imprime o \u00faltimo trade e o topo do book a cada novo neg\u00f3cio print(self.petr_trades[-1]) print(self.petr_book.bid[0]) print(self.petr_book.ask[0]) Candle Vazio Quando um candle de um determinado intervalo for inicializado pela passagem do tempo, antes de acontecer algum neg\u00f3cio naquele per\u00edodo, a callback de candles \u00e9 chamada usando o UpdateReason.NEW_BAR, contendo um candle com os valores OLHC do candle anterior. Neste caso a callback de trade n\u00e3o \u00e9 ativada. Direto No caso de sair um 'direto' a callback de book n\u00e3o \u00e9 ativada somente a callback de trade e candle. Utilit\u00e1rios Fun\u00e7\u00f5es n\u00e3o relacionadas diretamente \u00e0 assinaturas de candle/instrumento ou controle de ordens e posi\u00e7\u00e3o ficam dentro do m\u00f3dulo utils . Neste m\u00f3dulo existem as fun\u00e7\u00f5es a seguir: Fun\u00e7\u00e3o Descri\u00e7\u00e3o notify(<text>) Envia uma mensagem de no m\u00e1ximo 200 caracteres para o AlgoMan o qual dever\u00e1 notificar o frontend. A fun\u00e7\u00e3o retorna False se a string de entrada ultrapassa a quantidade de caracteres permitida ou o envio \u00e9 falho, retorna True no caso sucedido. text: string com at\u00e9 200 caracteres. now() Devolve o UNIX timestamp quit() Finaliza a estrategia chamando a callback de finalize com o valor reason=USER_QUIT by_price(side=<book_side>, depth=<max_rows>) Agrupa o book por pre\u00e7o de usando como entrada o lado (ask ou bid) do book passado como argumento (book_side). Se depth \u00e9 0 o book inteiro \u00e9 agrupado, caso contr\u00e1rio o book \u00e9 agrupado at\u00e9 gerar no m\u00e1ximo max_rows como sa\u00edda. Scheduler O usu\u00e1rio tem a possibilidade de cadastrar uma fun\u00e7\u00e3o para ser executada de acordo com um hor\u00e1rio espec\u00edfico ou a cada certo intervalo. Estas fun\u00e7\u00f5es encontram-se dentro do m\u00f3dulo utils . Fun\u00e7\u00e3o Descri\u00e7\u00e3o at(function=..., hour=.., minute=...) Agenda a fun\u00e7\u00e3o function para ser executada a determinada hora, com precis\u00e3o de hora e minute. No caso de par\u00e2metros inv\u00e1lidos de hora ([0-23]) e minuto ([0-59]) a fun\u00e7\u00e3o retorna None, caso contr\u00e1rio um objeto do tipo ScheduledFunction \u00e9 devolvido. every(function=...,interval=\\<seconds.ms\\>) Agenda a fun\u00e7\u00e3o function para ser executada com determinado intervalo. Intervalo m\u00ednimo de 0.250 s. No caso de par\u00e2metros inv\u00e1lidos de intervalo (\\< 0.250 s) a fun\u00e7\u00e3o retorna None, caso contr\u00e1rio um objeto do tipo ScheduledFunction \u00e9 devolvido. get_functions() Retorna uma lista com todas as fun\u00e7\u00f5es agendadas remove_function(function) Remove a fun\u00e7\u00e3o function. Caso function n\u00e3o exista a fun\u00e7\u00e3o retorna False, True caso contr\u00e1rio. No exemplo a seguir, a fun\u00e7ao opening ser\u00e1 executada as 10:00h e a fun\u00e7\u00e3o check ser\u00e1 executada a cada 0.5s: from neutrino import utils opening_event = utils.at(self.opening, 10, 00) check_event = utils.every(self.check, 0.5) Tamb\u00e9m \u00e9 poss\u00edvel recuperar e remover as fun\u00e7\u00f5es agendadas, assim como os outros callbacks registrados pelo usu\u00e1rio. Neste exemplo, o usu\u00e1rio remove os eventos agendados um a um: from neutrino import utils function = utils.get_functions() for function in functions: utils.remove_function(function) Lembre-se que: ao adicionar um evento no scheduler a callback default on_data assim como todas as callbacks cadastradas pelo usu\u00e1rio continuam sendo executadas normalmente; as fun\u00e7\u00f5es agendadas pelo utils.at s\u00e3o exclu\u00eddas logo ap\u00f3s serem executadas. no caso de tentar inserir um agendamento repetido, isto \u00e9 o mesmo para horario/intervalo - fun\u00e7\u00e3o, o objeto ja existente \u00e9 devolvido. o agendamento n\u00e3o suporta fun\u00e7\u00f5es sobrecarregadas, pois o nome da fun\u00e7\u00e3o \u00e9 usado para indexar os agendamentos internamente. Atributos Ao agendar uma fun\u00e7\u00e3o um objeto do tipo ScheduledFunction \u00e9 devolvido. Ele possui os seguintes atributos: function: objeto python apontando para a fun\u00e7\u00e3o que ser\u00e1 executada hour: hora do agendamento no formato 24h minute: minuto do agendamento interval: intervalo em segundos com precisao de 3 casas decimais. Caso o agendamento seja feito usando at, o campo interval \u00e9 igual a zero. No caso de ter usado a every os campos hour e minute s\u00e3o iguais a zero. SummaryLine O SummaryLine \u00e9 uma estrutura que cont\u00e9m dados operacionais sobre determinado ativo. Por meio dele \u00e9 poss\u00edvel consultar o topo do book, \u00faltimo trade, estat\u00edsticas, entre outros. Este conjunto de informa\u00e7\u00f5es visa reduzir o tr\u00e1fego para o neutrino evitando, por exemplo, assinar o book de certo ativo para conhecer o \u00faltimo pre\u00e7o de negocia\u00e7\u00e3o. O SummaryLine \u00e9 enviado ao neutrino a cada 200 ms. A tabela a seguir detalha a os campos desta estrutura: Campo Descri\u00e7\u00e3o symbol Nome do s\u00edmbolo assinado bid Estrutura BookEntry que indica o topo do lado da compra ask Estrutura BookEntry que indica o topo do lado da venda last_trade Estrutura TradeEntry com informa\u00e7\u00f5es do \u00faltimo negocio executado stats Estruturas SummaryLineStats com informa\u00e7\u00f5es estat\u00edsticas: trade_volume high low vwap opening closing theo settlement imbalance last tunnels Estrutura SummaryLineTunnels com informa\u00e7\u00f5es sobre tunnels: hard_limit auction_limit rejection_band static_limit status Estrutura StatusEntry com informa\u00e7\u00f5es sobre o estado do book Campo de BookEntry Descri\u00e7\u00e3o price quantity detail order_id Campo de TradeEntry Descri\u00e7\u00e3o price quantity buyer seller datetime status '+' compra, '-' venda, 'x' cross trade_id Campo de StatisticsEntry Descri\u00e7\u00e3o price quantity longnum Campo de TunnelEntry Descri\u00e7\u00e3o low_price high_price Campo de StatusEntry Descri\u00e7\u00e3o status 17: open open_trade_time Assinatura Para assinar um SummaryLine use a fun\u00e7\u00e3o add_summary e especifique o nome do ativo e callback opcionalmente. A assinatura de um SummaryLine n\u00e3o est\u00e1 vinculada \u00e0 assinatura de um InstrumentRegister , de modo que \u00e9 poss\u00edvel assinar o SummaryLine de m\u00faltiplos ativos sem sequer ter assinado o book de algum deles. Fun\u00e7\u00e3o Descri\u00e7\u00e3o add_summary(<symbol>, summary_callback=on_data) Adiciona um SummaryLine, usando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' summary_callback: callback a ser disparada na notifica\u00e7\u00e3o de recep\u00e7\u00e3o de SummaryLine ntidos no buffer a cada notifica\u00e7\u00e3o Um objeto do tipo SummaryLine \u00e9 devolvido no caso de sucesso. Caso o s\u00edmbolo n\u00e3o seja v\u00e1lido, None \u00e9 devolvido. O argumento summary_callback por padr\u00e3o \u00e9 a callback on_data por\u00e9m pode ser customizada. Em ambos casos, a callback recebe como argumento um objeto do tipo Update . Se a callback para o SummaryLine \u00e9 chamada, o vetor reason deste objeto cont\u00e9m um elemento com valor BookUpdateReason.SUMMARY_LINE . Por exemplo: from neutrino import market # Uso de callback customizadas self.win_summary = market.add_summary( 'WINQ19', summary_callback=on_summary) Acesso Para recuperar uma objeto SummaryLine use a funcao get_summary : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_summary(<symbol>) Use como argumento a string com o nome do ativo a ser assinado, ex. 'WINQ19'. Uma objeto do tipo SummaryLine \u00e9 devolvido ou None caso o s\u00edmbolo seja inv\u00e1lido ou n\u00e3o possua assinatura Por exemplo: from neutrino import market self.win_summary = market.get_summary('WINQ19') print(self.win_summary.stats.high.price) Desassinatura Para desassinar o SummaryLine use a funcao remove_summary : Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_summary(summary) Use como argumento um objeto SummaryLine existente obtido pelo retorno das fun\u00e7\u00f5es add_summary ou get_summary . Se objeto fornecido como par\u00e2metro \u00e9 inv\u00e1lido a fun\u00e7\u00e3o retorna False , True caso sucesso Por exemplo: from neutrino import market self.win_summary = market.add_summary('WINQ19') success = market.remove_summary(self.win_summary) Controle de recursos O usu\u00e1rio pode requisitar m\u00faltiplos recursos do sistema como memoria, disco e CPU. Este acesso pode ser feito diretamente invocando as pr\u00f3prias fun\u00e7\u00f5es do Python, por exemplo abrindo um arquivo e salvando nele quantidades absurdas de dados. Ou o acesso pode ser feito usando as fun\u00e7\u00f5es deste framework, por exemplo solicitando um buffer gigante para armazenar os trades. Como ambas situa\u00e7\u00f5es citadas acima geram risco, o Quantick deve deter o processo que ultrapasse os limiares seguros para funcionamento, auxiliando o controle dos recursos. Deste modo, o framework controla: Tamanho m\u00e1ximo dos buffers para book, trades e candles: quantidade de barras, entradas de book e trades dispon\u00edveis para o usu\u00e1rio. Quantidade m\u00e1xima de candles asssinados. Quantidade m\u00e1xima de indicadores assinados. Quantidade m\u00e1xima de callbacks assinadas. Quantidade m\u00e1xima de ativos. Frequencia m\u00e1xima das callbacks. Limite de intervalos para os candles e indicadores. Restringir o range de dados usados nos indicadores. e.g O tamanho da janela no moving average determina o custo em CPU do c\u00e1lculo de indicador. Data limite para a assinatura dos candles.","title":"Market Data API"},{"location":"mktdata/#market-data-api","text":"","title":"Market Data API"},{"location":"mktdata/#instrumento","text":"O InstrumentRegister representa o objeto pelo qual s\u00e3o disponibilizados o book e o buffer trades.","title":"Instrumento"},{"location":"mktdata/#assinatura","text":"Para assinar um instrumento use a fun\u00e7\u00e3o add especifique o nome do ativo, o tamanho do buffer de trades e as callbacks de mercado: Fun\u00e7\u00e3o Descri\u00e7\u00e3o add(<symbol>, book_callback=on_data, trade_callback=on_data, trade_buffer_size=64) Adiciona um instrumento, usando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' book_callback: callback a ser disparada na notifica\u00e7\u00e3o de mudan\u00e7a de book trade_callback: callback a ser disparada na notifica\u00e7\u00e3o de trade trade_buffer_size: quantidade m\u00e1xima de trades contidos no buffer a cada notifica\u00e7\u00e3o Um objeto do tipo InstrumentRegister \u00e9 devolvido no caso de sucesso. Caso o s\u00edmbolo n\u00e3o seja v\u00e1lido ou o tamanho do buffer ultrapasse 64 elementos, None \u00e9 devolvido. Por exemplo: from neutrino import market # Uso de duas callbacks customizadas self.win = market.add( 'WINQ19', book_callback=on_book, trade_callback=on_trade, trade_buffer_size=10) # Cancelada callback de book e uso de callback default on_data para trades self.wdo = market.add('WDOQ19', book_callback=None, trade_buffer_size=50) A callback default \u00e9 chamada on_data e precisa ser implementada pelo usu\u00e1rio para ser notificado sobre as mudan\u00e7as de book e trades. As assinaturas est\u00e3o baseadas em ativos podendo ser feitas em qualquer momento da opera\u00e7\u00e3o da estrat\u00e9gia. A assinatura de um ativo gera automaticamente estruturas de dados preenchidas com informa\u00e7\u00f5es do book e os trades que acontecem nesse momento. Vale lembrar que os trades do come\u00e7o do dia n\u00e3o est\u00e3o nesta lista.","title":"Assinatura"},{"location":"mktdata/#acesso","text":"Caso o instrumento n\u00e3o tenha sido salvo no momento da assinatura, \u00e9 poss\u00edvel utilizar a fun\u00e7\u00e3o get para recuper\u00e1-lo: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Devolve um instrumento j\u00e1 cadastrado usando como argumento a string com o nome do s\u00edmbolo. Caso o nome seja inv\u00e1lido None \u00e9 devolvido. Por exemplo: self.instrument = market.get('WINQ19')","title":"Acesso"},{"location":"mktdata/#desassinatura","text":"Para remover um instrumento utilize o objeto obtido pela cria\u00e7\u00e3o do mesmo: self.instrument = neutrino.market.get('WINDOM19') if neutrino.market.remove(self.instrument): print('success') A fun\u00e7\u00e3o remove \u00e9 parte do m\u00f3dulo market: Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove(<instrument>) Remove um instrumento. O instrument deve ser um objeto v\u00e1lido devolvido pela assinatura ou obtido pelo m\u00e9todo get. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto instrument passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. Na remo\u00e7\u00e3o de um instrumento os candles relacionado a ele n\u00e3o s\u00e3o removidos de maneira autom\u00e1tica, eles continuam sendo atualizados.","title":"Desassinatura"},{"location":"mktdata/#callbacks","text":"Ao assinar determinada estrutura de an\u00e1lise \u00e9 poss\u00edvel configurar as futuras callbacks, podendo mudar a callback default on_data para outra fun\u00e7\u00e3o, por exemplo: def initialize(self, symbols): market.add('WINQ19', book_callback=on_win_callback, trade_callback=None) market.add('WDOM19', book_callback=None, trade_callback=on_wdo_callback) def on_win_callback(self, update): print('WINQ19 bar received') def on_wdo_callback(self, update): print('WDOQ19 bar received') Inclusive \u00e9 possivel cancelar a callback para determinada assinatura. No exemplo a seguir, o usu\u00e1rio cancela a callback do book, por\u00e9m mantem as notifica\u00e7\u00f5es dos trades por meio da callback default on_data: def initialize(self, symbols): market.add('WINQ19', book_callback=None) def on_data(self, update): print('WINQ19 trade')","title":"Callbacks"},{"location":"mktdata/#atributos-e-metodos","text":"Os atributos a seguir est\u00e3o dispon\u00edvel para uma instancia do InstrumentRegister : name: nome do s\u00edmbolo book: book de ofertas trades: buffer circular de trades min_order_qty: lote m\u00ednimo price_increment: tick m\u00ednimo ready(): testa se o estado \u00e9 diferente de OFFLINE","title":"Atributos e m\u00e9todos"},{"location":"mktdata/#book","text":"bid: conjunto de ordens do lado da compra ask: conjunto de ordens do lado da venda state: enumerado com o estado do book, segundo a p\u00e1gina 64 desta documenta\u00e7\u00e3o. sequence: sequencial do book. Id \u00fanico da atualiza\u00e7\u00e3o mais recente do book de ofertas name: nome do s\u00edmbolo Cada item do bid e ask tem os seguintes atributos: price: pre\u00e7o da ordem quantity: quantidade da ordem detail: corretora order_id: SecondaryOrderID, definido pela Bolsa virtual_md_id: ID atribu\u00eddo \u00e0 ordem pelo neutrino Para imprimir o topo do book \u00e9 poss\u00edvel: print(instrument.bid[0].price) print(instrument.ask[0].price)","title":"Book"},{"location":"mktdata/#trades","text":"O acesso \u00e9 feito por meio de indices. O valor m\u00e1ximo \u00e9 determinado pelo par\u00e2metro trade_buffer_size. Os atributos de cada item s\u00e3o: trade_id: Id do trade na B3 datetime: hor\u00e1rio local quando o neg\u00f3cio foi executado price: pre\u00e7o do neg\u00f3cio quantity: quantidade do neg\u00f3cio buyer: contraparte compradora seller: contraparte vendedora status: \u00e9 o agressor indicator enviado pela bolsa. Pode ser R(trade de RLP), X(direto), -(trade iniciado pelo vendedor) e +(iniciado pelo comprador)","title":"Trades"},{"location":"mktdata/#candles","text":"O CandleRegister representa a estrutura que contem os candles para determinado ativo e as propriedades para sua constru\u00e7\u00e3o como intervalo, tick, quantidade inicial de barras, entre outros. Est\u00e3o dispon\u00edveis os candles do tipo stick e renko. A sua assinatura pode ser feita da maneira a seguir:","title":"Candles"},{"location":"mktdata/#assinatura_1","text":"A assinatura de um ativo pode ser feita por meio da fun\u00e7ao add_bar: Fun\u00e7\u00e3o Descri\u00e7\u00e3o add_bar(<symbol>,bar_count=100, interval=1) Adiciona um novo candle do tipo stick, utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' bar_count: n\u00famero de candles, default \u00e9 100. interval: intervalo para gera\u00e7\u00e3o dos candles, default \u00e9 1 minuto. Devolve um objeto do tipo CandleRegister. add_interday_bar(<symbol>,bar_count=100, interval='D') Adiciona um novo candle do tipo interday , utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' bar_count: n\u00famero de candles, default \u00e9 100 interval: intervalos poss\u00edveis s\u00e3o dia 'D' (default), semana 'W' e m\u00eas 'M' Devolve um objeto do tipo CandleRegister. add_renko(<symbol>,tick_count=2) Adiciona um novo candle do tipo renko, utilizando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' tick_count: n\u00edveis de pre\u00e7o para cada tijolo, default \u00e9 2 A quantidade de dias considerados para o hist\u00f3rico \u00e9 15. Devolve um objeto do tipo CandleRegister. Por exemplo: from neutrino import market bar = market.add_bar(symbol, bar_count=100, interval=1) interday_bar = market.add_interday_bar(symbol, bar_count=10, interval='M') renko = market.add_bar(symbol, tick_count=5) A assinatura de um instrumento e de barras s\u00e3o independentes , sendo que o usu\u00e1rio pode solicitar os candles de um determinado ativo usando a fun\u00e7\u00e3o add_bar , add_interday_bar ou add_renko sem ter adicionado o instrumento por meio do add . As atualiza\u00e7\u00f5es de candle chegar\u00e3o atrav\u00e9s da callback especificada para o trade_callback daquele instrumento ou no on_data , se nenhuma callback tiver sido especificado.","title":"Assinatura"},{"location":"mktdata/#acesso_1","text":"O armazenamento do candle \u00e9 responsabilidade do usu\u00e1rio, por\u00e9m caso o objeto n\u00e3o tenha sido salvo, \u00e9 poss\u00edvel recuper\u00e1-lo, utilizando a fun\u00e7\u00e3o get_bar , get_interday_bar ou get_renko : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_bar(<symbol>,bar_count=100, interval=1) get_interday_bar(<symbol>,bar_count=100, interval='D') get_renko(<symbol>,bar_count=2) Recupera um candle previamente cadastrado usando como argumentos: symbol: string com o nome do ativo a ser assinado. bar_count: n\u00famero de candles, default \u00e9 100. tick_count: n\u00edveis de pre\u00e7o para cada tijolo, default \u00e9 2. interval: intervalo para gera\u00e7\u00e3o dos candles, default \u00e9 1 minuto ou 'D'. Caso n\u00e3o exista um candle usando a combina\u00e7\u00e3o dos argumentos anteriores None \u00e9 devolvido , caso contr\u00e1rio o objeto do tipo CandleRegister Por exemplo: self.bar_win = market.get_bar('WINQ19') self.bar_win_count_1000 = market.get_bar('WINQ19', bar_count=1000) self.bar_win_interval_5 = market.get_bar('WINQ19', interval=5) self.bar_win_interval_day = market.get_interday_bar('WINQ19', interval='D') self.renko_win_10 = market.get_renko('WINQ19', tick_count=10)","title":"Acesso"},{"location":"mktdata/#atributos-e-metodos_1","text":"open high low close timestamps quantity quantity_buy quantity_sell volume quantity_accumulated quantity_buy_accumulated quantity_sell_accumulated num_trades last_id ready() properties: objeto do tipo CandleProperties, que por sua vez possui: tick_count: n\u00edveis de pre\u00e7o para cada tijolo bar_count: n\u00famero de barras solicitadas interval: periodo do candle em minutos ou especifica\u00e7\u00e3o 'D', 'W', 'M' para interday symbol: nome do ativo","title":"Atributos e m\u00e9todos"},{"location":"mktdata/#desassinatura_1","text":"Para remover um candle utilize o objeto CandleRegister devolvido na cria\u00e7\u00e3o do mesmo usando a fun\u00e7\u00e3o remove_bar , remove_interday_bar ou remove_renko : Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_bar(<bar>) remove_interday_bar(<bar>) remove_renko(<bar>) Remove um candle. O bar deve ser um objeto v\u00e1lido devolvido pela assinatura de um candle ou obtido pelo m\u00e9todo get_bar. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto bar passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. Por exemplo: from utils import market bar = market.add_bar('PETR4') if market.remove_bar(bar): print('success') Ao remover a assinatura de um candle todos os indicadores atrelados a ele tamb\u00e9m s\u00e3o removidos.","title":"Desassinatura"},{"location":"mktdata/#indicadores","text":"Os indicadores est\u00e3o naturalmente vinculados a um candle. Sendo que, a sua assinatura deve usar um objeto candle: self.bar_winq19 = neutrino.market.add_bar(\"WINQ19\") if self.bar_winq19.ready(): self.sma_winq19 = self.bar_winq19.add_sma(bar_count=10, source=neutrino.IndicatorSource.OPEN) print(self.bar_winq19.ready(), self.sma_winq19.ready()) # >> True, True Caso usu\u00e1rio n\u00e3o reserve uma vari\u00e1vel para salvar o indicador constru\u00eddo \u00e9 fornecido o seguinte mecanismo de acesso: for indicator in self.bar_winq19.get_indicators(): # retorna iterador print(\"Indicator \" + indicator.name + \" value: \" + str(indicator.values[-1]))","title":"Indicadores"},{"location":"mktdata/#indicadores-disponiveis","text":"O framework fornece os indicadores a seguir: Nome Assinatura Par\u00e2metros SMA add_sma(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada (conferir se\u00e7ao Source) EMA add_ema(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada MOM add_mom(bar_count=.., source=...) bar_count: quantidade de barras source: tipo de entrada SAMOM add_samom(bar_count=.., source=..., sa_bar_count=...) bar_count: quantidade de barras source: tipo de entrada sa_bar_count: quantidade de barras utilizadas na m\u00e9dia TRANGE* add_trange() SATR* add_satr(sa_bar_count=...) sa_bar_count: quantidade de barras utilizadas na m\u00e9dia ATR* add_atr(bar_count=...) bar_count: quantidade de barras ADX* add_atr(bar_count=...) bar_count: quantidade de barras SAADX* add_atr(bar_count=..., sa_bar_count=...) bar_count: quantidade de barras sa_bar_count: quantidade de barras utilizadas na m\u00e9dia PLUS_DI* add_plus_di(bar_count=...) bar_count: quantidade de barras MINUS_DI* add_minus_di(bar_count=...) bar_count: quantidade de barras BBANDS** add_bbands(bar_count=..., deviation_up=..., deviation_down=..., average=...) bar_count: quantidade de barras deviation_up: deviation_down: average: tipo de m\u00e9dia utiliza (conferir se\u00e7\u00e3o Average) SABBANDS** add_sabbands(bar_count=..., deviation_up=..., deviation_down=..., average=..., sa_bar_count=...) bar_count: quantidade de barras deviation_up: deviation_down: average: tipo de m\u00e9dia utiliza (conferir se\u00e7\u00e3o Average) sa_bar_count: quantidade de barras utilizadas na m\u00e9dia STDDEV add_stddev(bar_count=.., source=..., deviation_count=...) bar_count: quantidade de barras source: tipo de entrada deviation_count: * source utilizado: high, low, close ** source utilizado: close","title":"Indicadores dispon\u00edveis"},{"location":"mktdata/#acceso-aos-valores","text":"Os valores dos indicadores pode ser recuperado acessando o vetor de valores values: # Acessando o valor do indicador mais recente self.sma = candle.add_sma(10) print(self.sma.values[-1]) No caso do BBANDS e SABBANDS os valores devem ser acessados pelo vetor bands : # Acessando o valor do indicador mais recente self.sabbands = candle.add_bbands(bar_count=10, deviation_up=5, deviation_down=5, average=IndicatorAverage.SMA, sa_bar_count=5) print(self.sabbands.bands[0][-1]) print(self.sabbands.bands[1][-1] print(self.sabbands.bands[2][-1]","title":"Acceso aos valores"},{"location":"mktdata/#atributos","text":"Um indicador ao ser assinado ou ser recuperado usando a fun\u00e7\u00e3o get_indicators, possui a seguinte lista de atributos: values: lista com os valores do indicador bands: lista de 3 vetores com os valores para o BBANDS e SABBANDS last_id: id do valor de indicador atualizado mais recentemente name: nome do indicador (confira a coluna Nome na lista de Indicadores dispon\u00edveis) properties: itens da coluna Par\u00e2metros na lista de Indicadores dispon\u00edveis source bar_count sa_bar_count deviation_count deviation_up deviation_down average Todos os indicadores tem a lista anterior de atributos dispon\u00edveis independente do tipo de indicador.","title":"Atributos"},{"location":"mktdata/#source","text":"O argumento source para os indicadores \u00e9 determinado pelo enumerado neutrino.IndicatorSource, podendo ter os valores: NONE OPEN HIGH LOW CLOSE QUANTITY QUANTITY_SELL QUANTITY_BUY VOLUME QUANTITY_ACCUMULATED QUANTITY_SELL_ACCUMULATED QUANTITY_BUY_ACCUMULATED","title":"Source"},{"location":"mktdata/#average","text":"O argumento average para os indicadores BBANDS e SABBANDS \u00e9 determinado pelo enumador neutrino.IndicatorAverage, podendo ter os valores: SMA EMA WMA","title":"Average"},{"location":"mktdata/#desassinatura_2","text":"Para remover um indicador previamente criado \u00e9 necess\u00e1rio ter acesso ao objeto a ser removido. Use a fun\u00e7\u00e3o remove_indicator que \u00e9 um m\u00e9todo do CandleRegister. Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_indicator(<indicator>) Remove um indicador contido num candle. O indicator deve ser um objeto v\u00e1lido devolvido pela assinatura de um indicador ou obtido pelo m\u00e9todo get_indicators. A fun\u00e7\u00e3o retorna True em caso se sucesso, False caso contr\u00e1rio. O objeto indicator passado como par\u00e2metro \u00e9 invalidado no sucesso da opera\u00e7\u00e3o. No exemplo a seguir o objeto do indicador SMA \u00e9 salvo e utilizado para sua remo\u00e7\u00e3o: from utils import market bar = market.add_bar('PETR4') sma = bar.add_sma(10) if bar.remove_indicator(sma): print('success')","title":"Desassinatura"},{"location":"mktdata/#callbacks_1","text":"","title":"Callbacks"},{"location":"mktdata/#callbacks-inicio-e-fim","text":"A primeira callback da estrategia \u00e9 initialize. Esta fun\u00e7\u00e3o \u00e9 chamada pelo neutrino ap\u00f3s contrastar os ativos listados no arquivo de configura\u00e7\u00e3o da estrategia com o security list recebido pelo marketdata. De modo que, toda estrategia deve iniciar o seu processamento com instru\u00e7\u00f5es dentro da callback initialize. O par\u00e2metro symbols indica a lista de ativos dispn\u00edveis para uso. Este ativos correspondem ao mesmos especificados no arquivo de configura\u00e7\u00e3o da estrategia: # quantick.conf: \"Symbols\" : [ \"DI1F21\" , \"DI1F19\" , \"DI1F23\"], ... Considerando o arquivo anterior: def initialize(self, symbols) print([s for s in symbols]) # >> ['DI1F21', 'DI1F19', 'DI1F23'] A API tamb\u00e9m permite implementar a callback finalize (n\u00e3o obrigat\u00f3ria) que \u00e9 chamada quando a estrat\u00e9gia \u00e9 terminada por qualquer motivo: def initialize(self, symbols): neutrino.utils.quit() def finalize(self, reason): print(\"finalize:\" + str(reason))","title":"Callbacks inicio e fim"},{"location":"mktdata/#quitreason","text":"O neutrino sinaliza que a estrategia vai encerrar chamando a callback finalize. O par\u00e2metro reason indica o motivo do encerramento. Os valores para o QuitReason s\u00e3o: USER_QUIT: o usu\u00e1rio usou a chamada neutrino.utils.quit() ou usando CTRL+C ALGOMAN_QUIT: o Algoman enviou o comando Abort NO_MD_CONNECTION: perda de conex\u00e3o com a fonte de dados de mercado (Relay) NO_FRONTEND_CONNECTION: perda de conex\u00e3o com o frontend BAD_FD: falha na comunica\u00e7\u00e3o do neutrino com OMS ou Algoman ou Relay INVALID_PROTOCOL: pacote de dados recebido \u00e9 inv\u00e1lido OUT_OF_SYNC: a estrategia n\u00e3o consegue sincronizar ap\u00f3s 10 tentativas NO_OMS_CONNECTION: sem conex\u00e3o com o OMS","title":"QuitReason"},{"location":"mktdata/#callback-default-book-trade-e-candles","text":"O controle do volume de notifica\u00e7\u00f5es recebidas \u00e9 feito em parte pelo pr\u00f3prio usu\u00e1rio. Basicamente a fun\u00e7\u00e3o on_data ser\u00e1 disparada pelo Neutrino pela mudanca de book ou trades: No caso do book duas op\u00e7\u00f5es de atualiza\u00e7\u00e3o podem ser notificadas: bid e ask. No caso de trades, entende-se que os candles e indicadores tamb\u00e9m tem sido atualizados Quando acontecer a virada do periodo sem ter acontecido algum negocio o Neutrino notifica atualiza\u00e7\u00e3o dos candles/indicadores A callback default on_data tem como par\u00e2metro a estrutura update, tendo como membros os campos a seguir: symbol: nome do ativo atualizado e motivo da chamada da callback reason: vetor com a lista de acontecimentos motivo da chamada da callback bid_count: n\u00famero de atualiza\u00e7\u00f5es por parte do bid ask_count: n\u00famero de atualiza\u00e7\u00f5es por parte do ask trade_count: n\u00famero de trades status_changed: O campo reason \u00e9 um vetor ordenado levando em considera\u00e7\u00e3o como maior prioridade o acontecimento de um trade e a seguir o lado do book com maior quantidade de atualiza\u00e7\u00f5es. Por exemplo se existiram negocios e al\u00e9m disso bid_count > ask_count, ent\u00e3o: def on_data(self, update) print(update.symbol + ' - ' + ','.join(str(r) for r in update.reason)) # >> WINQ19 - TRADES, BID_SIDE, ASK_SIDE No exemplo a seguir o usu\u00e1rio assina book, trades, candle e indicadores para dois ativos diferentes. As mudan\u00e7as s\u00e3o recebidas pelo on_data e o pr\u00f3prio usu\u00e1rio \u00e9 respons\u00e1vel por determinar o tratamento de cada uma das op\u00e7\u00f5es poss\u00edveis: from neutrino import * def initalize(self) market.add_book(\"WINQ19\") market.add_book(\"PETR4\") self.winq_book = market.get_book(\"WINQ19\") self.petr_book = market.get_book(\"PETR4\") self.winq_candle = market.add_bar(\"WINQ19\", interval=1) self.petr_candle = market.add_bar(\"PETR4\", interval=5) self.winq_candle.add_sma(bar_count=5) self.petr_candle.add_sma(bar_count=10) self.petr_candle.add_adx() def on_data(self, update): if \"PETR4\" in update.symbol: self.on_petr_data(update) if \"WINQ19\" in update.symbol: self.on_winq_data(update) def on_petr_data(self, update): if UpdateReason.BID_SIDE in update.reason: self.on_petr_bid(update) if UpdateReason.ASK_SIDE in update.reason: self.on_petr_ask(update) if UpdateReason.TRADE in update.reason or \\ UpdateReason.NEW_BAR in update.reason: self.on_petr_candle(update) def on_winq_data(self, update): if UpdateReason.BID_SIDE in update.reason: self.on_winq_bid() if UpdateReason.ASK_SIDE in update.reason: self.on_winq_ask() if UpdateReason.TRADES in update.reason or \\ UpdateReason.NEW_BAR in update.reason: self.on_winq_candle() O framework permite tamb\u00e9m excluir a callback default de modo que as estruturas assinadas s\u00e3o atualizadas, por\u00e9m n\u00e3o existe notifica\u00e7\u00e3o deste acontecimento. Por exemplo, podem ser assinados book e trades por\u00e9m o book ser\u00e1 s\u00f3 consultado quando um trade acontecer. Para ter este efeito \u00e9 poss\u00edvel anular a callback do book: def initalize(self) market.add(\"PETR4\", book_callback=None) self.petr_book = market.get(\"PETR4\").book self.petr_trades = market.get(\"PETR4\").trades def on_data(self, update): # Imprime o \u00faltimo trade e o topo do book a cada novo neg\u00f3cio print(self.petr_trades[-1]) print(self.petr_book.bid[0]) print(self.petr_book.ask[0])","title":"Callback default, book, trade e candles"},{"location":"mktdata/#candle-vazio","text":"Quando um candle de um determinado intervalo for inicializado pela passagem do tempo, antes de acontecer algum neg\u00f3cio naquele per\u00edodo, a callback de candles \u00e9 chamada usando o UpdateReason.NEW_BAR, contendo um candle com os valores OLHC do candle anterior. Neste caso a callback de trade n\u00e3o \u00e9 ativada.","title":"Candle Vazio"},{"location":"mktdata/#direto","text":"No caso de sair um 'direto' a callback de book n\u00e3o \u00e9 ativada somente a callback de trade e candle.","title":"Direto"},{"location":"mktdata/#utilitarios","text":"Fun\u00e7\u00f5es n\u00e3o relacionadas diretamente \u00e0 assinaturas de candle/instrumento ou controle de ordens e posi\u00e7\u00e3o ficam dentro do m\u00f3dulo utils . Neste m\u00f3dulo existem as fun\u00e7\u00f5es a seguir: Fun\u00e7\u00e3o Descri\u00e7\u00e3o notify(<text>) Envia uma mensagem de no m\u00e1ximo 200 caracteres para o AlgoMan o qual dever\u00e1 notificar o frontend. A fun\u00e7\u00e3o retorna False se a string de entrada ultrapassa a quantidade de caracteres permitida ou o envio \u00e9 falho, retorna True no caso sucedido. text: string com at\u00e9 200 caracteres. now() Devolve o UNIX timestamp quit() Finaliza a estrategia chamando a callback de finalize com o valor reason=USER_QUIT by_price(side=<book_side>, depth=<max_rows>) Agrupa o book por pre\u00e7o de usando como entrada o lado (ask ou bid) do book passado como argumento (book_side). Se depth \u00e9 0 o book inteiro \u00e9 agrupado, caso contr\u00e1rio o book \u00e9 agrupado at\u00e9 gerar no m\u00e1ximo max_rows como sa\u00edda.","title":"Utilit\u00e1rios"},{"location":"mktdata/#scheduler","text":"O usu\u00e1rio tem a possibilidade de cadastrar uma fun\u00e7\u00e3o para ser executada de acordo com um hor\u00e1rio espec\u00edfico ou a cada certo intervalo. Estas fun\u00e7\u00f5es encontram-se dentro do m\u00f3dulo utils . Fun\u00e7\u00e3o Descri\u00e7\u00e3o at(function=..., hour=.., minute=...) Agenda a fun\u00e7\u00e3o function para ser executada a determinada hora, com precis\u00e3o de hora e minute. No caso de par\u00e2metros inv\u00e1lidos de hora ([0-23]) e minuto ([0-59]) a fun\u00e7\u00e3o retorna None, caso contr\u00e1rio um objeto do tipo ScheduledFunction \u00e9 devolvido. every(function=...,interval=\\<seconds.ms\\>) Agenda a fun\u00e7\u00e3o function para ser executada com determinado intervalo. Intervalo m\u00ednimo de 0.250 s. No caso de par\u00e2metros inv\u00e1lidos de intervalo (\\< 0.250 s) a fun\u00e7\u00e3o retorna None, caso contr\u00e1rio um objeto do tipo ScheduledFunction \u00e9 devolvido. get_functions() Retorna uma lista com todas as fun\u00e7\u00f5es agendadas remove_function(function) Remove a fun\u00e7\u00e3o function. Caso function n\u00e3o exista a fun\u00e7\u00e3o retorna False, True caso contr\u00e1rio. No exemplo a seguir, a fun\u00e7ao opening ser\u00e1 executada as 10:00h e a fun\u00e7\u00e3o check ser\u00e1 executada a cada 0.5s: from neutrino import utils opening_event = utils.at(self.opening, 10, 00) check_event = utils.every(self.check, 0.5) Tamb\u00e9m \u00e9 poss\u00edvel recuperar e remover as fun\u00e7\u00f5es agendadas, assim como os outros callbacks registrados pelo usu\u00e1rio. Neste exemplo, o usu\u00e1rio remove os eventos agendados um a um: from neutrino import utils function = utils.get_functions() for function in functions: utils.remove_function(function) Lembre-se que: ao adicionar um evento no scheduler a callback default on_data assim como todas as callbacks cadastradas pelo usu\u00e1rio continuam sendo executadas normalmente; as fun\u00e7\u00f5es agendadas pelo utils.at s\u00e3o exclu\u00eddas logo ap\u00f3s serem executadas. no caso de tentar inserir um agendamento repetido, isto \u00e9 o mesmo para horario/intervalo - fun\u00e7\u00e3o, o objeto ja existente \u00e9 devolvido. o agendamento n\u00e3o suporta fun\u00e7\u00f5es sobrecarregadas, pois o nome da fun\u00e7\u00e3o \u00e9 usado para indexar os agendamentos internamente.","title":"Scheduler"},{"location":"mktdata/#atributos_1","text":"Ao agendar uma fun\u00e7\u00e3o um objeto do tipo ScheduledFunction \u00e9 devolvido. Ele possui os seguintes atributos: function: objeto python apontando para a fun\u00e7\u00e3o que ser\u00e1 executada hour: hora do agendamento no formato 24h minute: minuto do agendamento interval: intervalo em segundos com precisao de 3 casas decimais. Caso o agendamento seja feito usando at, o campo interval \u00e9 igual a zero. No caso de ter usado a every os campos hour e minute s\u00e3o iguais a zero.","title":"Atributos"},{"location":"mktdata/#summaryline","text":"O SummaryLine \u00e9 uma estrutura que cont\u00e9m dados operacionais sobre determinado ativo. Por meio dele \u00e9 poss\u00edvel consultar o topo do book, \u00faltimo trade, estat\u00edsticas, entre outros. Este conjunto de informa\u00e7\u00f5es visa reduzir o tr\u00e1fego para o neutrino evitando, por exemplo, assinar o book de certo ativo para conhecer o \u00faltimo pre\u00e7o de negocia\u00e7\u00e3o. O SummaryLine \u00e9 enviado ao neutrino a cada 200 ms. A tabela a seguir detalha a os campos desta estrutura: Campo Descri\u00e7\u00e3o symbol Nome do s\u00edmbolo assinado bid Estrutura BookEntry que indica o topo do lado da compra ask Estrutura BookEntry que indica o topo do lado da venda last_trade Estrutura TradeEntry com informa\u00e7\u00f5es do \u00faltimo negocio executado stats Estruturas SummaryLineStats com informa\u00e7\u00f5es estat\u00edsticas: trade_volume high low vwap opening closing theo settlement imbalance last tunnels Estrutura SummaryLineTunnels com informa\u00e7\u00f5es sobre tunnels: hard_limit auction_limit rejection_band static_limit status Estrutura StatusEntry com informa\u00e7\u00f5es sobre o estado do book Campo de BookEntry Descri\u00e7\u00e3o price quantity detail order_id Campo de TradeEntry Descri\u00e7\u00e3o price quantity buyer seller datetime status '+' compra, '-' venda, 'x' cross trade_id Campo de StatisticsEntry Descri\u00e7\u00e3o price quantity longnum Campo de TunnelEntry Descri\u00e7\u00e3o low_price high_price Campo de StatusEntry Descri\u00e7\u00e3o status 17: open open_trade_time","title":"SummaryLine"},{"location":"mktdata/#assinatura_2","text":"Para assinar um SummaryLine use a fun\u00e7\u00e3o add_summary e especifique o nome do ativo e callback opcionalmente. A assinatura de um SummaryLine n\u00e3o est\u00e1 vinculada \u00e0 assinatura de um InstrumentRegister , de modo que \u00e9 poss\u00edvel assinar o SummaryLine de m\u00faltiplos ativos sem sequer ter assinado o book de algum deles. Fun\u00e7\u00e3o Descri\u00e7\u00e3o add_summary(<symbol>, summary_callback=on_data) Adiciona um SummaryLine, usando como argumentos: symbol: string com o nome do ativo a ser assinado, ex. 'WINQ19' summary_callback: callback a ser disparada na notifica\u00e7\u00e3o de recep\u00e7\u00e3o de SummaryLine ntidos no buffer a cada notifica\u00e7\u00e3o Um objeto do tipo SummaryLine \u00e9 devolvido no caso de sucesso. Caso o s\u00edmbolo n\u00e3o seja v\u00e1lido, None \u00e9 devolvido. O argumento summary_callback por padr\u00e3o \u00e9 a callback on_data por\u00e9m pode ser customizada. Em ambos casos, a callback recebe como argumento um objeto do tipo Update . Se a callback para o SummaryLine \u00e9 chamada, o vetor reason deste objeto cont\u00e9m um elemento com valor BookUpdateReason.SUMMARY_LINE . Por exemplo: from neutrino import market # Uso de callback customizadas self.win_summary = market.add_summary( 'WINQ19', summary_callback=on_summary)","title":"Assinatura"},{"location":"mktdata/#acesso_2","text":"Para recuperar uma objeto SummaryLine use a funcao get_summary : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_summary(<symbol>) Use como argumento a string com o nome do ativo a ser assinado, ex. 'WINQ19'. Uma objeto do tipo SummaryLine \u00e9 devolvido ou None caso o s\u00edmbolo seja inv\u00e1lido ou n\u00e3o possua assinatura Por exemplo: from neutrino import market self.win_summary = market.get_summary('WINQ19') print(self.win_summary.stats.high.price)","title":"Acesso"},{"location":"mktdata/#desassinatura_3","text":"Para desassinar o SummaryLine use a funcao remove_summary : Fun\u00e7\u00e3o Descri\u00e7\u00e3o remove_summary(summary) Use como argumento um objeto SummaryLine existente obtido pelo retorno das fun\u00e7\u00f5es add_summary ou get_summary . Se objeto fornecido como par\u00e2metro \u00e9 inv\u00e1lido a fun\u00e7\u00e3o retorna False , True caso sucesso Por exemplo: from neutrino import market self.win_summary = market.add_summary('WINQ19') success = market.remove_summary(self.win_summary)","title":"Desassinatura"},{"location":"mktdata/#controle-de-recursos","text":"O usu\u00e1rio pode requisitar m\u00faltiplos recursos do sistema como memoria, disco e CPU. Este acesso pode ser feito diretamente invocando as pr\u00f3prias fun\u00e7\u00f5es do Python, por exemplo abrindo um arquivo e salvando nele quantidades absurdas de dados. Ou o acesso pode ser feito usando as fun\u00e7\u00f5es deste framework, por exemplo solicitando um buffer gigante para armazenar os trades. Como ambas situa\u00e7\u00f5es citadas acima geram risco, o Quantick deve deter o processo que ultrapasse os limiares seguros para funcionamento, auxiliando o controle dos recursos. Deste modo, o framework controla: Tamanho m\u00e1ximo dos buffers para book, trades e candles: quantidade de barras, entradas de book e trades dispon\u00edveis para o usu\u00e1rio. Quantidade m\u00e1xima de candles asssinados. Quantidade m\u00e1xima de indicadores assinados. Quantidade m\u00e1xima de callbacks assinadas. Quantidade m\u00e1xima de ativos. Frequencia m\u00e1xima das callbacks. Limite de intervalos para os candles e indicadores. Restringir o range de dados usados nos indicadores. e.g O tamanho da janela no moving average determina o custo em CPU do c\u00e1lculo de indicador. Data limite para a assinatura dos candles.","title":"Controle de recursos"},{"location":"orders/","text":"Order Routing API O controle de ordens est\u00e1 estruturado nos m\u00f3dulos a seguir: oms : contem as funcionalidades para gerenciamento de ordens position : gerencia a posi\u00e7\u00e3o do usu\u00e1rio risk : apresenta o risco configurado OMS O m\u00f3dulo oms contem todas as transa\u00e7\u00f5es (de todos os ativos e tipos) e os respectivos assessores para sua manipula\u00e7\u00e3o. Esse objeto ser\u00e1 o respons\u00e1vel por guardar os estados das transa\u00e7\u00f5es de ordens e sinalizar o algoritmo \u00e0 cada mudan\u00e7a. O objeto que representa uma ordem \u00e9 denominado OrderEntry. Um objeto deste tipo cont\u00e9m todas as informa\u00e7\u00f5es que descrevem o estado atual da ordem e suas propriedades. Do mesmo modo, fornece certos m\u00e9todos para facilitar a sua an\u00e1lise e modificaca\u00e7\u00e3o OrderEntry Uma ordem est\u00e1 definida pelo objeto OrderEntry o qual possui as seguintes propriedades e fun\u00e7\u00f5es: Propriedades Nome da propriedade Descri\u00e7\u00e3o unique_id N\u00famero inteiro identificador \u00fanico da ordem gerado pelo neutrino para auxiliar o programador. Esse id se mant\u00e9m o mesmo durante toda a vida da ordem e n\u00e3o faz refer\u00eancia ao \"OrderID\" gerado pela bolsa side Enumerado do tipo Side (Ser\u00e1 descrito abaixo) e indica se \u00e9 uma ordem de compra ou venda. type Enumerado do tipo OrderType (Ser\u00e1 descrito abaixo) que indica o tipo da ordem ( Limite, Mercado ou Start/Stop). time_in_force Enumerado do tipo TimeInForce (Ser\u00e1 descrito abaixo) que representa o Campo 59 do FIX (a validade da ordem - Dia, VAC ou GTD). status Enumerado do tipo OrderStatus (ser\u00e1 descrito abaixo) que \u00e9 a combina\u00e7\u00e3o entre os campos 39 e 150 do FIX. price Valor num\u00e9rico que representa o pre\u00e7o Limite da ordem. last_price Valor num\u00e9rico que representa o pre\u00e7o da \u00faltima execu\u00e7\u00e3o. trigger_price Valor num\u00e9rico que representa o pre\u00e7o de gatilho da ordem (caso a ordem n\u00e3o seja de gatilho, ser\u00e1 zero). quantity Valor num\u00e9rico que representa o quantidade original da ordem. last_quantity Valor num\u00e9rico que representa o quantidade executada na transa\u00e7\u00e3o atual. filled_quantity Valor num\u00e9rico que representa o quantidade total executada. leaves_quantity Valor num\u00e9rico que representa o quantidade ainda dispon\u00edvel no book. transact_time Valor num\u00e9rico que representa o timestamp da intera\u00e7\u00e3o de ordem. account String contendo a conta para a qual a estrat\u00e9gia est\u00e1 operando. symbol String com o nome do contrato. client_order_id String com o campo 11 do FIX que representa o id da transa\u00e7\u00e3o. Esse id ser\u00e1 gerenciado pelo Neutrino. ** original_client_order_id String com o campo 41 do FIX que representa o client_order_id da transa\u00e7\u00e3o anterior. Tamb\u00e9m ser\u00e1 gerenciado pelo Neutrino. order_id String com o campo 37 do FIX que representa o id \u00fanico da ordem atribu\u00eddo pela Bolsa, e por isso mesmo s\u00f3 ser\u00e1 preenchido em ordens que foram confirmadas, caso contr\u00e1rio ser\u00e1 vazio. secondary_order_id String com o id da oferta no book de ofertas. Quando presente, esse id vem pelo marketdata mas n\u00e3o \u00e9 garantido que ele seja disponibilizado por todos os feeders de marketdata. Ser\u00e1 branco caso n\u00e3o o feeder n\u00e3o o disponibilize. ** Observa\u00e7\u00e3o: A string gerada pelo neutrino como o ClOrdID (client_order_id) cont\u00e9m o tranche_id do algoritmo codificado nela. Para recuperar o valor original, no python, pode-se rodar int(<ClOrdID>.split('.')[1][2:8], 16) , onde \u00e9 uma string. O valor obtido deve corresponder ao PID presente no arquivo de configura\u00e7\u00e3o da estrat\u00e9gia. Enumerados Nome Descri\u00e7\u00e3o OrdeSide BID: identifica uma ordem de compra ASK: identifica uma ordem de venda OrderType LIMIT, MARKET, STOP, STOP_LIMIT TimeInForce DAY, FAK, FOK OrderStatus WAIT: estado inicial de toda ordem antes da confirma\u00e7\u00e3o ou rejei\u00e7\u00e3o WAIT_CANCEL: estado ap\u00f3s solicita\u00e7\u00e3o de cancelamento e antes da confirma\u00e7\u00e3o/rejei\u00e7\u00e3o ACTIVE: ordem ativa aceita pela bolsa e apresentada no book WAIT_REPLACE: estado retornar ap\u00f3s solicita\u00e7\u00e3o de altera\u00e7\u00e3o da ordem REPLACED: estado de confirma\u00e7\u00e3o de altera\u00e7\u00e3o da ordem, a qual \u00e9 apresentada no book com as mudan\u00e7as solicitadas FILLED: ordem executada PARTIAL_FILLED: ordem parcialmente executada, na qual a quantidade solicitada n\u00e3o foi atingida por\u00e9m somente parte dela. CANCELED: ordem cancelada \u00e0 solicita\u00e7\u00e3o do usu\u00e1rio REJECTED: ordem rejeitada M\u00e9todos Nome do m\u00e9todo Descri\u00e7\u00e3o is_execution() Retorna True caso a ordem represente uma execu\u00e7\u00e3o, False caso contr\u00e1rio is_dead() Retorna True caso a ordem esteja em um estado final irrevers\u00edvel (cancelada, executada ou rejeitada caso a ordem nunca tenha sido aceita), False caso contr\u00e1rio. is_alive() Retorna True caso a ordem esteja num estado que pode ser alterado por a\u00e7\u00e3o do algoritmo ou do mercado (ativa, modificada), False caso contr\u00e1rio. is_pending() Retorna True caso a ordem esteja em inflight (wait, wait cancel ou wait replace), False caso contr\u00e1rio. replace() cancel() Envio de ordens Cada fun\u00e7\u00e3o de envio de ordens retonar um n\u00famero que se for positivo representar\u00e1 o id \u00fanico da ordem que foi criada (apenas no caso de ordem nova, j\u00e1 que esse id nunca mudar\u00e1 mesmo que a ordem seja modificada/cancelada), este identificador \u00e9 denominado unique_id. Para envio, mudan\u00e7a ou cancelamento de ordens podem ser utilizadas as fun\u00e7\u00f5es a seguir: Nome da fun\u00e7\u00e3o Descri\u00e7\u00e3o send(symbol=, side=, price=, quantity=, time_in_force=TimeInForce.DAY) Envia uma ordem de tipo limite, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default DAY . Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. send(symbol=, side=, trigger_price=, price=, quantity=, time_in_force=TimeInForce.DAY) Envia uma ordem de tipo gatilho, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o trigger_price : valor do pre\u00e7o gatilho quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default DAY. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. send(symbol=, side=, quantity=) Envia uma ordem de tipo mercado, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. is_dead() Retorna True caso a ordem esteja em um estado final irrevers\u00edvel (CANCELED, FILLED, REJECTED ou REJECTED caso a ordem nunca tenha sido aceita), False caso contr\u00e1rio. is_alive() Retorna True caso a ordem esteja num estado que pode ser alterado por a\u00e7\u00e3o do algoritmo ou do mercado (ACTIVE, REPLACED), False caso contr\u00e1rio. is_pending() Retorna True caso a ordem esteja em inflight (WAIT, WAIT_CANCEL ou WAIT_REPLACE), False caso contr\u00e1rio. replace(order=, price=, quantity=, time_in_force=) replace(order=, price=, quantity=) Modifica uma ordem de tipo limite, usando como argumentos: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update price : valor do pre\u00e7o quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default \u00e9 o valor do TIF da ordem em quest\u00e3o. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. replace(symbol=, trigger_price=, price=, quantity=, time_in_force=) replace(symbol=, trigger_price=, price=, quantity=) Modifica uma ordem de tipo gatilho, usando como argumentos: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update price : valor do pre\u00e7o trigger_price : valor do pre\u00e7o gatilho quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default \u00e9 o valor do TIF da ordem em quest\u00e3o. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. cancel(<order>) Cancela determinada ordem, sendo que o cancelamento \u00e9 comum \u00e0 todos os tipos de ordens. Usa como argumento: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. cancel_all(<symbol>, <side>=NONE_SIDE, <price>=NONE_) Cancela o grupo de ordens do ativo symbol , sendo poss\u00edvel filtrar pelo lado e/ou pre\u00e7o. symbol : nome do ativo side : OrderSide::BID ou OrderSide::ASK price: valor do pre\u00e7o Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. No caso do m\u00e9todo send recomenda-se o uso dos argumentos com os nomes para evitar conflitos entre Caso o valor de retorno no envio, mudan\u00e7a ou cancelamento de ordens seja um n\u00famero negativo ele representa um c\u00f3digo de falha a ser tratado pelo programador. O acontecimento de qualquer falha indicar\u00e1 que essa ordem n\u00e3o existe no mercado e por isso n\u00e3o haver\u00e1 qualquer tipo de report via order_update(order) para ela. Os poss\u00edve\u00eds c\u00f3digos de erro s\u00e3o: Valor de retorno Descri\u00e7\u00e3o unique_id (>0) ID \u00fanico da ordem OK (0) Envio de ordem OK. ORDER_NOT_FOUND (-1) Ordem n\u00e3o encontrada RISK_INVALID_NET (-2) Ordem n\u00e3o aceita pelo controle de risco INVALID_QUANTITY (-3) Quantidade inv\u00e1lida (por exemplo: quantidade negativa) INFLIGHT (-4) Ordem pendente UNKNOWN (-5) OMS_DISCONNECTED (-6) OMS desconectado INVALID_SYMBOL (-7) S\u00edmbolo inv\u00e1lido no contexto da estrat\u00e9gia INVALID_PRICE (-8) Pre\u00e7o inv\u00e1lido NOT_SUPPORTED (-9) Ordem n\u00e3o suportada Vale ressaltar que, na modifica\u00e7\u00e3o de ordens, mesmo que o programador altere os campos da ordem, apenas seu pre\u00e7o e quantidade s\u00e3o pass\u00edveis de modifica\u00e7\u00f5es. Al\u00e9m disso, para modificar ou cancelar uma ordem, deve-se usar de um objeto OrderEntry como argumento, o qual pode ser recebido pelo update_order(order) quando encontrada via get_live_orders. Gerenciamento do WAIT Ao utilizar as fun\u00e7\u00f5es de envio, modifica\u00e7\u00e3o ou cancelamento de ordens \u00e9 poss\u00edvel ou n\u00e3o receber o status WAIT a partir da corretora. O neutrino opta por colocar a ordem em WAIT, WAIT_REPLACE ou WAIT_CANCEL de maneira inmediata apenas as fun\u00e7\u00f5es de envio, modifica\u00e7\u00e3o ou cancelamento sejam invocadas. Este fato acontece independentemente de ter ou n\u00e3o recebido o status WAIT pela corretora. Caso ocorra de receber o status WAIT da corretora, ele \u00e9 ignorado e a callback order_update \u00e9 chamada notificando que existe uma ordem em WAIT. Caso ocorra de n\u00e3o receber o status WAIT da corretora, a callback order_update s\u00f3 ser\u00e1 chamada ao receber da corretora o estado da ordem em quest\u00e3o (ACTIVE ou REJECTED). Nesse momento, o neutrino informa via callback num primeiro momento que existe uma ordem em WAIT e em sequ\u00eancia uma nova chamada \u00e0 callback order_update informando o estatdo da ordem (ACTIVE ou REJECTED). Callback de Ordens As repostas ao envio, modifica\u00e7\u00e3o e cancelamento de ordens s\u00e3o notificadas ao usu\u00e1rio utilizando a callback order_update. De maneira opcional, caso o usu\u00e1rio precise ser notificado somente das execu\u00e7\u00f5es \u00e9 poss\u00edvel utilizar a callback order_filled. Nome da callback Descri\u00e7\u00e3o order_update(<order>) Por esse callback o algoritmo ser\u00e1 notificado \u00e0 cada mudan\u00e7a de estado das das ordens v\u00e1lidas e essa notifica\u00e7\u00f5es depender\u00e3o da m\u00e1quina de estados do protocolo usado pela corretora. (Confira a se\u00e7\u00e3o Gerenciamento do WAIT). O argumento utilizado \u00e9: order : objeto OrderEntry atualizado com informa\u00e7\u00f5es recebidas pela corretora order_filled(<order>, <price>, <quantity>) Callback opcional, a qual ser\u00e1 chamada antes do order_update caso definida no algoritmo, reportando somente as execu\u00e7\u00f5es. Ap\u00f3s a chamada desta callback, a order_update ser\u00e1 invocada. order : objeto OrderEntry atualizado com informa\u00e7\u00f5es recebidas pela corretora price: pre\u00e7o da execu\u00e7\u00e3o quantity: quantidade executada Consulta de Ordens Internamente o neutrino armazena uma lista com as ordens indicando o \u00faltimo estado na qual se encontram. A partir desta lista s\u00e3o disponibilizados m\u00e9todos de acesso para filtrar e obter informa\u00e7\u00f5es do conteudo desta lista. Os m\u00e9todos de consulta encontram-se no m\u00f3dulo oms : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_orders(<symbol>=\"\", <side>=NONE_SIDE, <price>=-1) Recupera a lista de todas as ordens criadas no seu \u00faltimo estado. Utiliza como filtro: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o Se s\u00e3o utilizados os valores default o filtro ignora esse campo e utiliza os restantes. Caso todos sejam default, a lista completa \u00e9 devolvida. get_live_orders(<symbol>=\"\", <side>=NONE_SIDE, <price>=-1) Recupera a lista de todas as ordens criadas nas quais o seu estado seja: ACTIVE, REPLACED ou PARTIAL_FILLED. Utiliza os mesmos filtros que a fun\u00e7\u00e3o get_orders. get_total_quantity(<symbol>, <side>, <status_combination>=0) Recupera o acumulado das quantidades das ordens para o atibo symbol e lado side . O bitmask status_combination especifica o filtro utilizado para o c\u00e1lculo. O filtro representa uma combina\u00e7\u00e3o dos poss\u00edveis estados da ordem. No caso de solicitar ordens em ativas e executas, utilize status_combination = (OrderStatus::ACTIVE | OrderStatus::FILLED) get_order_by_id(<unique_id>) Recupera a ordem pelo unique_id . Retorna None caso n\u00e3o exista uma ordem com o unique_id fornecido. Controle de Risco O m\u00f3dulo de risco tem a fun\u00e7\u00e3o de n\u00e3o permitir que seja ultrapassado o limite de posi\u00e7\u00e3o configurado no neutrino. Ap\u00f3s atingir esse limite apenas as ordens que diminuam a posi\u00e7\u00e3o ser\u00e3o aceitas al\u00e9m de permitir a virada de m\u00e3o. A configura\u00e7\u00e3o do risco \u00e9 feita por meio da mensagem de controle do frontend ControlAlgo usando o comando Set . A mensagem ControlAlgo no seu campo Tunables deve conter o max_position. Este campo pode ser composto por m\u00faltiplos objetos indexados pelo nome do ativo. Cada item, deve ter dois campos obrigat\u00f3rios limit , o qual indica o valor m\u00e1ximo a ser atingido e o campo type_limit , indicando se o valor refere-se a uma quantidade ou um valor financeiro. Neste exemplo, dois ativos s\u00e3o configurados. O primeiro deles utiliza um limite em quantidade e o segundo em financeiro: { \"Tunables\": { \"FooStrategyName\": { \"max_position\": { \"DI1F21\": { \"limit\": 200, \"type_limit\": \"quantity\" }, \"DI1F22\": { \"limit\": 400, \"type_limit\": \"financial\" } } } } } Para acessar aos valores de risco dentro da estrategia utilize o m\u00f3dulo risk, por meio da fun\u00e7\u00e3o get: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Recupera a estrutura RiskData com os valores de risco para o ativo symbol A estrutura RiskData \u00e9 composta por: Atributo Descri\u00e7\u00e3o limit Valor m\u00e1ximo a ser atingido ap\u00f3s a conclus\u00e3o da opera\u00e7\u00e3o type_limit Tipo risco, sendo poss\u00edvel: QUANTITY FINANCIAL Baseado na configura\u00e7\u00e3o anterior \u00e9 poss\u00edvel utilizar o m\u00f3dulo de risco da maneira a seguir: win_risk = neutrino.risk.get('DI1F21') print(win_risk.limit) # >> 200 print(win_risk.type_limit) # >> QUANTITY As ordens que forem rejeitadas pelo risco tem o c\u00f3digo de erro RISK_INVALID_NET . Portanto ela n\u00e3o notificar\u00e1 o algoritmo via order_update() . A rejei\u00e7\u00e3o pelo risco \u00e9 detectada ao comparar os valores de limite e a soma das quantidades de ordens executadas (FILLED e PARTIAL_FILLED), ordens ativas ou pendentes (ACTIVE, REPLACED, WAIT e WAIT_CANCEL) e da nova ordem enviada. Controle de Posi\u00e7\u00e3o O controle de posi\u00e7\u00e3o est\u00e1 contido no m\u00f3dulo position. Por meio dele \u00e9 poss\u00edvel acessar a posi\u00e7\u00e3o de determinado ativo: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Recupera a posi\u00e7\u00e3o para o ativo symbol, retornando um objeto PositionStatus Um objeto da classe PositionStatus contem os atributos a seguir: Atributo Descri\u00e7\u00e3o total Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o total partial Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o parcial initial Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o inicial Cada objeto PositionData contem: Atributo Descri\u00e7\u00e3o net Quantidade da posi\u00e7\u00e3o net_price Pre\u00e7o m\u00e9dio bid_quantity Quantidade da compra ask_quantity Quantidade da venda bid_volume Volume da compra ask_volume Volume da venda","title":"Orders Routing API"},{"location":"orders/#order-routing-api","text":"O controle de ordens est\u00e1 estruturado nos m\u00f3dulos a seguir: oms : contem as funcionalidades para gerenciamento de ordens position : gerencia a posi\u00e7\u00e3o do usu\u00e1rio risk : apresenta o risco configurado","title":"Order Routing API"},{"location":"orders/#oms","text":"O m\u00f3dulo oms contem todas as transa\u00e7\u00f5es (de todos os ativos e tipos) e os respectivos assessores para sua manipula\u00e7\u00e3o. Esse objeto ser\u00e1 o respons\u00e1vel por guardar os estados das transa\u00e7\u00f5es de ordens e sinalizar o algoritmo \u00e0 cada mudan\u00e7a. O objeto que representa uma ordem \u00e9 denominado OrderEntry. Um objeto deste tipo cont\u00e9m todas as informa\u00e7\u00f5es que descrevem o estado atual da ordem e suas propriedades. Do mesmo modo, fornece certos m\u00e9todos para facilitar a sua an\u00e1lise e modificaca\u00e7\u00e3o","title":"OMS"},{"location":"orders/#orderentry","text":"Uma ordem est\u00e1 definida pelo objeto OrderEntry o qual possui as seguintes propriedades e fun\u00e7\u00f5es:","title":"OrderEntry"},{"location":"orders/#propriedades","text":"Nome da propriedade Descri\u00e7\u00e3o unique_id N\u00famero inteiro identificador \u00fanico da ordem gerado pelo neutrino para auxiliar o programador. Esse id se mant\u00e9m o mesmo durante toda a vida da ordem e n\u00e3o faz refer\u00eancia ao \"OrderID\" gerado pela bolsa side Enumerado do tipo Side (Ser\u00e1 descrito abaixo) e indica se \u00e9 uma ordem de compra ou venda. type Enumerado do tipo OrderType (Ser\u00e1 descrito abaixo) que indica o tipo da ordem ( Limite, Mercado ou Start/Stop). time_in_force Enumerado do tipo TimeInForce (Ser\u00e1 descrito abaixo) que representa o Campo 59 do FIX (a validade da ordem - Dia, VAC ou GTD). status Enumerado do tipo OrderStatus (ser\u00e1 descrito abaixo) que \u00e9 a combina\u00e7\u00e3o entre os campos 39 e 150 do FIX. price Valor num\u00e9rico que representa o pre\u00e7o Limite da ordem. last_price Valor num\u00e9rico que representa o pre\u00e7o da \u00faltima execu\u00e7\u00e3o. trigger_price Valor num\u00e9rico que representa o pre\u00e7o de gatilho da ordem (caso a ordem n\u00e3o seja de gatilho, ser\u00e1 zero). quantity Valor num\u00e9rico que representa o quantidade original da ordem. last_quantity Valor num\u00e9rico que representa o quantidade executada na transa\u00e7\u00e3o atual. filled_quantity Valor num\u00e9rico que representa o quantidade total executada. leaves_quantity Valor num\u00e9rico que representa o quantidade ainda dispon\u00edvel no book. transact_time Valor num\u00e9rico que representa o timestamp da intera\u00e7\u00e3o de ordem. account String contendo a conta para a qual a estrat\u00e9gia est\u00e1 operando. symbol String com o nome do contrato. client_order_id String com o campo 11 do FIX que representa o id da transa\u00e7\u00e3o. Esse id ser\u00e1 gerenciado pelo Neutrino. ** original_client_order_id String com o campo 41 do FIX que representa o client_order_id da transa\u00e7\u00e3o anterior. Tamb\u00e9m ser\u00e1 gerenciado pelo Neutrino. order_id String com o campo 37 do FIX que representa o id \u00fanico da ordem atribu\u00eddo pela Bolsa, e por isso mesmo s\u00f3 ser\u00e1 preenchido em ordens que foram confirmadas, caso contr\u00e1rio ser\u00e1 vazio. secondary_order_id String com o id da oferta no book de ofertas. Quando presente, esse id vem pelo marketdata mas n\u00e3o \u00e9 garantido que ele seja disponibilizado por todos os feeders de marketdata. Ser\u00e1 branco caso n\u00e3o o feeder n\u00e3o o disponibilize. ** Observa\u00e7\u00e3o: A string gerada pelo neutrino como o ClOrdID (client_order_id) cont\u00e9m o tranche_id do algoritmo codificado nela. Para recuperar o valor original, no python, pode-se rodar int(<ClOrdID>.split('.')[1][2:8], 16) , onde \u00e9 uma string. O valor obtido deve corresponder ao PID presente no arquivo de configura\u00e7\u00e3o da estrat\u00e9gia.","title":"Propriedades"},{"location":"orders/#enumerados","text":"Nome Descri\u00e7\u00e3o OrdeSide BID: identifica uma ordem de compra ASK: identifica uma ordem de venda OrderType LIMIT, MARKET, STOP, STOP_LIMIT TimeInForce DAY, FAK, FOK OrderStatus WAIT: estado inicial de toda ordem antes da confirma\u00e7\u00e3o ou rejei\u00e7\u00e3o WAIT_CANCEL: estado ap\u00f3s solicita\u00e7\u00e3o de cancelamento e antes da confirma\u00e7\u00e3o/rejei\u00e7\u00e3o ACTIVE: ordem ativa aceita pela bolsa e apresentada no book WAIT_REPLACE: estado retornar ap\u00f3s solicita\u00e7\u00e3o de altera\u00e7\u00e3o da ordem REPLACED: estado de confirma\u00e7\u00e3o de altera\u00e7\u00e3o da ordem, a qual \u00e9 apresentada no book com as mudan\u00e7as solicitadas FILLED: ordem executada PARTIAL_FILLED: ordem parcialmente executada, na qual a quantidade solicitada n\u00e3o foi atingida por\u00e9m somente parte dela. CANCELED: ordem cancelada \u00e0 solicita\u00e7\u00e3o do usu\u00e1rio REJECTED: ordem rejeitada","title":"Enumerados"},{"location":"orders/#metodos","text":"Nome do m\u00e9todo Descri\u00e7\u00e3o is_execution() Retorna True caso a ordem represente uma execu\u00e7\u00e3o, False caso contr\u00e1rio is_dead() Retorna True caso a ordem esteja em um estado final irrevers\u00edvel (cancelada, executada ou rejeitada caso a ordem nunca tenha sido aceita), False caso contr\u00e1rio. is_alive() Retorna True caso a ordem esteja num estado que pode ser alterado por a\u00e7\u00e3o do algoritmo ou do mercado (ativa, modificada), False caso contr\u00e1rio. is_pending() Retorna True caso a ordem esteja em inflight (wait, wait cancel ou wait replace), False caso contr\u00e1rio. replace() cancel()","title":"M\u00e9todos"},{"location":"orders/#envio-de-ordens","text":"Cada fun\u00e7\u00e3o de envio de ordens retonar um n\u00famero que se for positivo representar\u00e1 o id \u00fanico da ordem que foi criada (apenas no caso de ordem nova, j\u00e1 que esse id nunca mudar\u00e1 mesmo que a ordem seja modificada/cancelada), este identificador \u00e9 denominado unique_id. Para envio, mudan\u00e7a ou cancelamento de ordens podem ser utilizadas as fun\u00e7\u00f5es a seguir: Nome da fun\u00e7\u00e3o Descri\u00e7\u00e3o send(symbol=, side=, price=, quantity=, time_in_force=TimeInForce.DAY) Envia uma ordem de tipo limite, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default DAY . Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. send(symbol=, side=, trigger_price=, price=, quantity=, time_in_force=TimeInForce.DAY) Envia uma ordem de tipo gatilho, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o trigger_price : valor do pre\u00e7o gatilho quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default DAY. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. send(symbol=, side=, quantity=) Envia uma ordem de tipo mercado, usando como argumentos: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. is_dead() Retorna True caso a ordem esteja em um estado final irrevers\u00edvel (CANCELED, FILLED, REJECTED ou REJECTED caso a ordem nunca tenha sido aceita), False caso contr\u00e1rio. is_alive() Retorna True caso a ordem esteja num estado que pode ser alterado por a\u00e7\u00e3o do algoritmo ou do mercado (ACTIVE, REPLACED), False caso contr\u00e1rio. is_pending() Retorna True caso a ordem esteja em inflight (WAIT, WAIT_CANCEL ou WAIT_REPLACE), False caso contr\u00e1rio. replace(order=, price=, quantity=, time_in_force=) replace(order=, price=, quantity=) Modifica uma ordem de tipo limite, usando como argumentos: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update price : valor do pre\u00e7o quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default \u00e9 o valor do TIF da ordem em quest\u00e3o. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. replace(symbol=, trigger_price=, price=, quantity=, time_in_force=) replace(symbol=, trigger_price=, price=, quantity=) Modifica uma ordem de tipo gatilho, usando como argumentos: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update price : valor do pre\u00e7o trigger_price : valor do pre\u00e7o gatilho quantity : quantidade inteira m\u00faltipla do lote m\u00ednimo time_in_force : validade da ordem determinado pelo enumerado TimeInForce, default \u00e9 o valor do TIF da ordem em quest\u00e3o. Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. cancel(<order>) Cancela determinada ordem, sendo que o cancelamento \u00e9 comum \u00e0 todos os tipos de ordens. Usa como argumento: order : objeto do tipo OrderEntry podendo ser obtido pelas fun\u00e7\u00f5es de consulta ou pela callback order_update Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. cancel_all(<symbol>, <side>=NONE_SIDE, <price>=NONE_) Cancela o grupo de ordens do ativo symbol , sendo poss\u00edvel filtrar pelo lado e/ou pre\u00e7o. symbol : nome do ativo side : OrderSide::BID ou OrderSide::ASK price: valor do pre\u00e7o Retorna unique_id ( inteiro > 0) no caso de sucesso, ou c\u00f3digo de erro caso contr\u00e1rio. No caso do m\u00e9todo send recomenda-se o uso dos argumentos com os nomes para evitar conflitos entre Caso o valor de retorno no envio, mudan\u00e7a ou cancelamento de ordens seja um n\u00famero negativo ele representa um c\u00f3digo de falha a ser tratado pelo programador. O acontecimento de qualquer falha indicar\u00e1 que essa ordem n\u00e3o existe no mercado e por isso n\u00e3o haver\u00e1 qualquer tipo de report via order_update(order) para ela. Os poss\u00edve\u00eds c\u00f3digos de erro s\u00e3o: Valor de retorno Descri\u00e7\u00e3o unique_id (>0) ID \u00fanico da ordem OK (0) Envio de ordem OK. ORDER_NOT_FOUND (-1) Ordem n\u00e3o encontrada RISK_INVALID_NET (-2) Ordem n\u00e3o aceita pelo controle de risco INVALID_QUANTITY (-3) Quantidade inv\u00e1lida (por exemplo: quantidade negativa) INFLIGHT (-4) Ordem pendente UNKNOWN (-5) OMS_DISCONNECTED (-6) OMS desconectado INVALID_SYMBOL (-7) S\u00edmbolo inv\u00e1lido no contexto da estrat\u00e9gia INVALID_PRICE (-8) Pre\u00e7o inv\u00e1lido NOT_SUPPORTED (-9) Ordem n\u00e3o suportada Vale ressaltar que, na modifica\u00e7\u00e3o de ordens, mesmo que o programador altere os campos da ordem, apenas seu pre\u00e7o e quantidade s\u00e3o pass\u00edveis de modifica\u00e7\u00f5es. Al\u00e9m disso, para modificar ou cancelar uma ordem, deve-se usar de um objeto OrderEntry como argumento, o qual pode ser recebido pelo update_order(order) quando encontrada via get_live_orders.","title":"Envio de ordens"},{"location":"orders/#gerenciamento-do-wait","text":"Ao utilizar as fun\u00e7\u00f5es de envio, modifica\u00e7\u00e3o ou cancelamento de ordens \u00e9 poss\u00edvel ou n\u00e3o receber o status WAIT a partir da corretora. O neutrino opta por colocar a ordem em WAIT, WAIT_REPLACE ou WAIT_CANCEL de maneira inmediata apenas as fun\u00e7\u00f5es de envio, modifica\u00e7\u00e3o ou cancelamento sejam invocadas. Este fato acontece independentemente de ter ou n\u00e3o recebido o status WAIT pela corretora. Caso ocorra de receber o status WAIT da corretora, ele \u00e9 ignorado e a callback order_update \u00e9 chamada notificando que existe uma ordem em WAIT. Caso ocorra de n\u00e3o receber o status WAIT da corretora, a callback order_update s\u00f3 ser\u00e1 chamada ao receber da corretora o estado da ordem em quest\u00e3o (ACTIVE ou REJECTED). Nesse momento, o neutrino informa via callback num primeiro momento que existe uma ordem em WAIT e em sequ\u00eancia uma nova chamada \u00e0 callback order_update informando o estatdo da ordem (ACTIVE ou REJECTED).","title":"Gerenciamento do WAIT"},{"location":"orders/#callback-de-ordens","text":"As repostas ao envio, modifica\u00e7\u00e3o e cancelamento de ordens s\u00e3o notificadas ao usu\u00e1rio utilizando a callback order_update. De maneira opcional, caso o usu\u00e1rio precise ser notificado somente das execu\u00e7\u00f5es \u00e9 poss\u00edvel utilizar a callback order_filled. Nome da callback Descri\u00e7\u00e3o order_update(<order>) Por esse callback o algoritmo ser\u00e1 notificado \u00e0 cada mudan\u00e7a de estado das das ordens v\u00e1lidas e essa notifica\u00e7\u00f5es depender\u00e3o da m\u00e1quina de estados do protocolo usado pela corretora. (Confira a se\u00e7\u00e3o Gerenciamento do WAIT). O argumento utilizado \u00e9: order : objeto OrderEntry atualizado com informa\u00e7\u00f5es recebidas pela corretora order_filled(<order>, <price>, <quantity>) Callback opcional, a qual ser\u00e1 chamada antes do order_update caso definida no algoritmo, reportando somente as execu\u00e7\u00f5es. Ap\u00f3s a chamada desta callback, a order_update ser\u00e1 invocada. order : objeto OrderEntry atualizado com informa\u00e7\u00f5es recebidas pela corretora price: pre\u00e7o da execu\u00e7\u00e3o quantity: quantidade executada","title":"Callback de Ordens"},{"location":"orders/#consulta-de-ordens","text":"Internamente o neutrino armazena uma lista com as ordens indicando o \u00faltimo estado na qual se encontram. A partir desta lista s\u00e3o disponibilizados m\u00e9todos de acesso para filtrar e obter informa\u00e7\u00f5es do conteudo desta lista. Os m\u00e9todos de consulta encontram-se no m\u00f3dulo oms : Fun\u00e7\u00e3o Descri\u00e7\u00e3o get_orders(<symbol>=\"\", <side>=NONE_SIDE, <price>=-1) Recupera a lista de todas as ordens criadas no seu \u00faltimo estado. Utiliza como filtro: symbol: nome do ativo side: OrderSide::BID ou OrderSide::ASK price : valor do pre\u00e7o Se s\u00e3o utilizados os valores default o filtro ignora esse campo e utiliza os restantes. Caso todos sejam default, a lista completa \u00e9 devolvida. get_live_orders(<symbol>=\"\", <side>=NONE_SIDE, <price>=-1) Recupera a lista de todas as ordens criadas nas quais o seu estado seja: ACTIVE, REPLACED ou PARTIAL_FILLED. Utiliza os mesmos filtros que a fun\u00e7\u00e3o get_orders. get_total_quantity(<symbol>, <side>, <status_combination>=0) Recupera o acumulado das quantidades das ordens para o atibo symbol e lado side . O bitmask status_combination especifica o filtro utilizado para o c\u00e1lculo. O filtro representa uma combina\u00e7\u00e3o dos poss\u00edveis estados da ordem. No caso de solicitar ordens em ativas e executas, utilize status_combination = (OrderStatus::ACTIVE | OrderStatus::FILLED) get_order_by_id(<unique_id>) Recupera a ordem pelo unique_id . Retorna None caso n\u00e3o exista uma ordem com o unique_id fornecido.","title":"Consulta de Ordens"},{"location":"orders/#controle-de-risco","text":"O m\u00f3dulo de risco tem a fun\u00e7\u00e3o de n\u00e3o permitir que seja ultrapassado o limite de posi\u00e7\u00e3o configurado no neutrino. Ap\u00f3s atingir esse limite apenas as ordens que diminuam a posi\u00e7\u00e3o ser\u00e3o aceitas al\u00e9m de permitir a virada de m\u00e3o. A configura\u00e7\u00e3o do risco \u00e9 feita por meio da mensagem de controle do frontend ControlAlgo usando o comando Set . A mensagem ControlAlgo no seu campo Tunables deve conter o max_position. Este campo pode ser composto por m\u00faltiplos objetos indexados pelo nome do ativo. Cada item, deve ter dois campos obrigat\u00f3rios limit , o qual indica o valor m\u00e1ximo a ser atingido e o campo type_limit , indicando se o valor refere-se a uma quantidade ou um valor financeiro. Neste exemplo, dois ativos s\u00e3o configurados. O primeiro deles utiliza um limite em quantidade e o segundo em financeiro: { \"Tunables\": { \"FooStrategyName\": { \"max_position\": { \"DI1F21\": { \"limit\": 200, \"type_limit\": \"quantity\" }, \"DI1F22\": { \"limit\": 400, \"type_limit\": \"financial\" } } } } } Para acessar aos valores de risco dentro da estrategia utilize o m\u00f3dulo risk, por meio da fun\u00e7\u00e3o get: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Recupera a estrutura RiskData com os valores de risco para o ativo symbol A estrutura RiskData \u00e9 composta por: Atributo Descri\u00e7\u00e3o limit Valor m\u00e1ximo a ser atingido ap\u00f3s a conclus\u00e3o da opera\u00e7\u00e3o type_limit Tipo risco, sendo poss\u00edvel: QUANTITY FINANCIAL Baseado na configura\u00e7\u00e3o anterior \u00e9 poss\u00edvel utilizar o m\u00f3dulo de risco da maneira a seguir: win_risk = neutrino.risk.get('DI1F21') print(win_risk.limit) # >> 200 print(win_risk.type_limit) # >> QUANTITY As ordens que forem rejeitadas pelo risco tem o c\u00f3digo de erro RISK_INVALID_NET . Portanto ela n\u00e3o notificar\u00e1 o algoritmo via order_update() . A rejei\u00e7\u00e3o pelo risco \u00e9 detectada ao comparar os valores de limite e a soma das quantidades de ordens executadas (FILLED e PARTIAL_FILLED), ordens ativas ou pendentes (ACTIVE, REPLACED, WAIT e WAIT_CANCEL) e da nova ordem enviada.","title":"Controle de Risco"},{"location":"orders/#controle-de-posicao","text":"O controle de posi\u00e7\u00e3o est\u00e1 contido no m\u00f3dulo position. Por meio dele \u00e9 poss\u00edvel acessar a posi\u00e7\u00e3o de determinado ativo: Fun\u00e7\u00e3o Descri\u00e7\u00e3o get(<symbol>) Recupera a posi\u00e7\u00e3o para o ativo symbol, retornando um objeto PositionStatus Um objeto da classe PositionStatus contem os atributos a seguir: Atributo Descri\u00e7\u00e3o total Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o total partial Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o parcial initial Objeto PositionData contendo informa\u00e7\u00f5es sobre a posi\u00e7\u00e3o inicial Cada objeto PositionData contem: Atributo Descri\u00e7\u00e3o net Quantidade da posi\u00e7\u00e3o net_price Pre\u00e7o m\u00e9dio bid_quantity Quantidade da compra ask_quantity Quantidade da venda bid_volume Volume da compra ask_volume Volume da venda","title":"Controle de Posi\u00e7\u00e3o"}]}